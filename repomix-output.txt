This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-14T02:47:19.700Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.claude/
  settings.local.json
app/
  api/
    check-env/
      route.ts
    firestarter/
      create/
        route.ts
      debug/
        route.ts
      query/
        route.ts
    indexes/
      route.ts
    scrape/
      route.ts
    v1/
      chat/
        completions/
          route.ts
  dashboard/
    page.tsx
  debug/
    page.tsx
  indexes/
    page.tsx
  globals.css
  layout.tsx
  page.tsx
components/
  ui/
    alert-dialog.tsx
    button.tsx
    dialog.tsx
    input.tsx
    menubar.tsx
    navigation-menu.tsx
    pagination.tsx
    popover.tsx
    progress.tsx
    radio-group.tsx
    resizable.tsx
    scroll-area.tsx
    select.tsx
    separator.tsx
    sheet.tsx
    sidebar.tsx
    skeleton.tsx
    slider.tsx
    sonner.tsx
    switch.tsx
    table.tsx
    tabs.tsx
    textarea.tsx
    toggle-group.tsx
    toggle.tsx
    tooltip.tsx
hooks/
  use-mobile.ts
  useStorage.ts
lib/
  utils/
    source-context.ts
  error-handler.ts
  firecrawl.ts
  langgraph-search-engine.ts
  rate-limit.ts
  search-engine.ts
  storage.ts
  upstash-search.ts
  utils.ts
public/
  assets/
    twemoji-fire.svg
  file.svg
  firecrawl-logo.svg
  globe.svg
  window.svg
.gitignore
components.json
eslint.config.mjs
layout.tsx
next.config.ts
package.json
postcss.config.mjs
tailwind.config.ts
tsconfig.json
vercel.json

================================================================
Files
================================================================

================
File: .claude/settings.local.json
================
{
  "permissions": {
    "allow": [
      "Bash(npm run build:*)",
      "Bash(npm run dev:*)",
      "Bash(npx prettier:*)",
      "Bash(npm install:*)",
      "Bash(pnpm add:*)",
      "Bash(rg:*)"
    ],
    "deny": []
  }
}

================
File: app/api/check-env/route.ts
================
import { NextResponse } from 'next/server';

export async function GET() {
  const environmentStatus = {
    FIRECRAWL_API_KEY: !!process.env.FIRECRAWL_API_KEY,
    OPENAI_API_KEY: !!process.env.OPENAI_API_KEY,
    ANTHROPIC_API_KEY: !!process.env.ANTHROPIC_API_KEY,
    FIRESTARTER_DISABLE_CREATION_DASHBOARD: process.env.FIRESTARTER_DISABLE_CREATION_DASHBOARD === 'true',
  };

  return NextResponse.json({ environmentStatus });
}

================
File: app/api/firestarter/create/route.ts
================
import { NextRequest, NextResponse } from 'next/server'
import FirecrawlApp from '@mendable/firecrawl-js'
import { searchIndex } from '@/lib/upstash-search'
import { saveIndex } from '@/lib/storage'

export async function POST(request: NextRequest) {
  try {
    // Check if creation is disabled
    if (process.env.FIRESTARTER_DISABLE_CREATION_DASHBOARD === 'true') {
      console.log('[FIRESTARTER-CREATE] Creation is disabled via FIRESTARTER_DISABLE_CREATION_DASHBOARD')
      return NextResponse.json({ 
        error: 'Dashboard creation is disabled for Firestarter.' 
      }, { status: 403 })
    }

    const { url, limit = 10, includePaths, excludePaths } = await request.json()
    console.log('[FIRESTARTER-CREATE] Received crawl request for URL:', url, 'with limit:', limit)
    if (includePaths) console.log('[FIRESTARTER-CREATE] Include paths:', includePaths)
    if (excludePaths) console.log('[FIRESTARTER-CREATE] Exclude paths:', excludePaths)
    
    if (!url) {
      console.error('[FIRESTARTER-CREATE] No URL provided in request')
      return NextResponse.json({ error: 'URL is required' }, { status: 400 })
    }

    // Generate unique namespace with timestamp to avoid collisions
    const baseNamespace = new URL(url).hostname.replace(/\./g, '-')
    const timestamp = Date.now()
    const namespace = `${baseNamespace}-${timestamp}`
    console.log('[FIRESTARTER-CREATE] Generated namespace:', namespace)
    
    // Initialize Firecrawl with API key from environment or headers
    const apiKey = process.env.FIRECRAWL_API_KEY || request.headers.get('X-Firecrawl-API-Key')
    if (!apiKey) {
      console.error('[FIRESTARTER-CREATE] FIRECRAWL_API_KEY is not set in environment variables or headers')
      return NextResponse.json({ 
        error: 'Firecrawl API key is not configured. Please provide your API key.' 
      }, { status: 500 })
    }
    
    console.log('[FIRESTARTER-CREATE] Initializing Firecrawl client')
    const firecrawl = new FirecrawlApp({
      apiKey: apiKey
    })

    // Start crawling the website with specified limit
    console.log('[FIRESTARTER-CREATE] Starting crawl for', url, 'with limit of', limit, 'pages')
    
    const crawlOptions: any = {
      limit: limit,
      scrapeOptions: {
        formats: ['markdown', 'html'],
        maxAge: 604800, // 1 week in seconds (7 * 24 * 60 * 60)
      }
    }
    
    // Add include/exclude paths if provided
    if (includePaths && Array.isArray(includePaths) && includePaths.length > 0) {
      crawlOptions.includePaths = includePaths
    }
    if (excludePaths && Array.isArray(excludePaths) && excludePaths.length > 0) {
      crawlOptions.excludePaths = excludePaths
    }
    
    const crawlResponse = await firecrawl.crawlUrl(url, crawlOptions) as {
      success: boolean
      data: Array<{
        url?: string
        markdown?: string
        content?: string
        metadata?: {
          title?: string
          description?: string
          ogDescription?: string
          sourceURL?: string
          favicon?: string
          ogImage?: string
          'og:image'?: string
        }
      }>
    }
    
    console.log('[FIRESTARTER-CREATE] Full crawl response:', JSON.stringify(crawlResponse, null, 2))
    
    // Store the crawl data for immediate use
    const crawlId = 'immediate-' + Date.now()
    console.log('[FIRESTARTER-CREATE] Crawl completed successfully!')
    console.log('[FIRESTARTER-CREATE] Pages crawled:', crawlResponse.data?.length || 0)
    
    // Log first page content preview for debugging
    if (crawlResponse.data && crawlResponse.data.length > 0) {
      // Find the homepage in the crawled data
      const homepage = crawlResponse.data.find((page) => {
        const pageUrl = page.metadata?.sourceURL || page.url || ''
        // Check if it's the homepage (ends with domain or domain/)
        return pageUrl === url || pageUrl === url + '/' || pageUrl === url.replace(/\/$/, '')
      }) || crawlResponse.data[0] // Fallback to first page
      
      // Log homepage info for debugging but don't store it in unused variable
      console.log('[FIRESTARTER-CREATE] Homepage metadata:', homepage.metadata)
      
      console.log('[FIRESTARTER-CREATE] Homepage URL:', homepage.metadata?.sourceURL || homepage.url)
      console.log('[FIRESTARTER-CREATE] Homepage title:', homepage.metadata?.title || 'No title')
      console.log('[FIRESTARTER-CREATE] Homepage OG image:', homepage.metadata?.ogImage || homepage.metadata?.['og:image'])
      console.log('[FIRESTARTER-CREATE] Content preview:', homepage.markdown?.substring(0, 200) + '...')
    }
    
    // Store documents in Upstash Search
    console.log('[FIRESTARTER-CREATE] Storing documents in Upstash Search...')
    const documents = crawlResponse.data.map((page, index) => {
      // Get the content and metadata
      const fullContent = page.markdown || page.content || ''
      const title = page.metadata?.title || 'Untitled'
      const url = page.metadata?.sourceURL || page.url || ''
      const description = page.metadata?.description || page.metadata?.ogDescription || ''
      
      // Create a searchable text - include namespace for better search filtering
      // The limit is 1500 chars for the whole content object when stringified
      const searchableText = `namespace:${namespace} ${title} ${description} ${fullContent}`.substring(0, 1000)
      
      return {
        id: `${namespace}-${index}`,
        content: {
          text: searchableText  // Content must be an object
        },
        metadata: {
          namespace: namespace,
          title: title,
          url: url,
          sourceURL: page.metadata?.sourceURL || page.url || '',
          crawlDate: new Date().toISOString(),
          pageTitle: page.metadata?.title,
          description: page.metadata?.description || page.metadata?.ogDescription,
          favicon: page.metadata?.favicon,
          ogImage: page.metadata?.ogImage || page.metadata?.['og:image'],
          // Store the full content in metadata for retrieval (not searchable but accessible)
          fullContent: fullContent.substring(0, 5000) // Store more content here
        }
      }
    })
    
    // Store documents in batches
    const batchSize = 10
    console.log('[FIRESTARTER-CREATE] Attempting to store', documents.length, 'documents in Upstash')
    
    try {
      for (let i = 0; i < documents.length; i += batchSize) {
        const batch = documents.slice(i, i + batchSize)
        console.log(`[FIRESTARTER-CREATE] Storing batch ${i/batchSize + 1} with ${batch.length} documents`)
        const upsertResult = await searchIndex.upsert(batch)
        console.log(`[FIRESTARTER-CREATE] Batch ${i/batchSize + 1} upsert result:`, upsertResult)
      }
      
      console.log('[FIRESTARTER-CREATE] Successfully stored', documents.length, 'documents in Upstash')
      
      // Verify documents were stored - try multiple approaches
      console.log('[FIRESTARTER-CREATE] Verifying document storage...')
      
      // First try with filter
      interface SearchResult {
        metadata?: {
          namespace?: string
        }
      }
      let verifyResult: SearchResult[] = []
      try {
        verifyResult = await searchIndex.search({
          query: documents[0]?.content?.title || 'test',
          filter: `metadata.namespace = "${namespace}"`,
          limit: 1
        })
        console.log('[FIRESTARTER-CREATE] Verification with filter found:', verifyResult.length, 'documents')
      } catch {
        console.log('[FIRESTARTER-CREATE] Verification with filter failed, trying without filter')
        
        // Try without filter
        try {
          const allResults = await searchIndex.search({
            query: namespace, // Search for the namespace itself
            limit: 10
          })
          console.log('[FIRESTARTER-CREATE] Verification without filter found:', allResults.length, 'total documents')
          
          // Log the structure of the first result for debugging
          if (allResults.length > 0) {
            console.log('[FIRESTARTER-CREATE] First document structure:', JSON.stringify(allResults[0], null, 2))
          }
          
          // Manual filter check
          verifyResult = allResults.filter((doc: SearchResult) => {
            const docNamespace = doc.metadata?.namespace
            return docNamespace === namespace
          })
          console.log('[FIRESTARTER-CREATE] Manual filter found:', verifyResult.length, 'matching documents')
        } catch (noFilterError) {
          console.error('[FIRESTARTER-CREATE] Verification without filter also failed:', noFilterError)
        }
      }
      
      if (verifyResult.length === 0) {
        console.warn('[FIRESTARTER-CREATE] WARNING: Could not verify documents were stored correctly!')
        console.log('[FIRESTARTER-CREATE] Sample document structure that was upserted:', JSON.stringify(documents[0], null, 2))
      } else {
        console.log('[FIRESTARTER-CREATE] Successfully verified document storage')
      }
    } catch (upsertError) {
      console.error('[FIRESTARTER-CREATE] Error storing documents in Upstash:', upsertError)
      throw new Error(`Failed to store documents: ${upsertError instanceof Error ? upsertError.message : 'Unknown error'}`)
    }
    
    // Save index metadata to storage
    const homepage = crawlResponse.data.find((page) => {
      const pageUrl = page.metadata?.sourceURL || page.url || ''
      return pageUrl === url || pageUrl === url + '/' || pageUrl === url.replace(/\/$/, '')
    }) || crawlResponse.data[0]
    
    await saveIndex({
      url,
      namespace,
      pagesCrawled: crawlResponse.data?.length || 0,
      createdAt: new Date().toISOString(),
      metadata: {
        title: homepage?.metadata?.title,
        description: homepage?.metadata?.description || homepage?.metadata?.ogDescription,
        favicon: homepage?.metadata?.favicon,
        ogImage: homepage?.metadata?.ogImage || homepage?.metadata?.['og:image']
      }
    })
    
    return NextResponse.json({
      success: true,
      namespace,
      crawlId,
      message: `Crawl completed successfully (limited to ${limit} pages)`,
      details: {
        url,
        pagesLimit: limit,
        pagesCrawled: crawlResponse.data?.length || 0,
        formats: ['markdown', 'html']
      },
      data: crawlResponse.data // Include the actual crawl data
    })
  } catch (error) {
    console.error('[FIRESTARTER-CREATE] Error in create route:', error)
    
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred'
    const statusCode = error && typeof error === 'object' && 'statusCode' in error ? error.statusCode : undefined
    
    console.error('[FIRESTARTER-CREATE] Error details:', {
      message: errorMessage,
      statusCode: statusCode,
      details: error && typeof error === 'object' && 'details' in error ? error.details : undefined,
      stack: error instanceof Error ? error.stack : undefined
    })
    
    // Provide more specific error messages
    if (statusCode === 401) {
      return NextResponse.json(
        { error: 'Firecrawl authentication failed. Please check your API key.' },
        { status: 401 }
      )
    }
    
    return NextResponse.json(
      { 
        error: 'Failed to start crawl',
        details: errorMessage
      },
      { status: 500 }
    )
  }
}

================
File: app/api/firestarter/debug/route.ts
================
import { NextRequest, NextResponse } from 'next/server'
import { searchIndex } from '@/lib/upstash-search'

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams
    const namespace = searchParams.get('namespace')
    
    console.log('[FIRESTARTER-DEBUG] Debug endpoint called with namespace:', namespace)
    
    // Try different search approaches
    interface DebugResults {
      namespaceSearch?: {
        count: number
        items: unknown[]
      }
      namespaceSearchError?: string
      allSearch?: {
        count: number
        items: unknown[]
      }
      allSearchError?: string
      semanticSearch?: {
        count: number
        items: unknown[]
      }
      semanticSearchError?: string
    }
    const results: DebugResults = {}
    
    // 1. Search with namespace filter
    if (namespace) {
      try {
        const namespaceSearch = await searchIndex.search({
          query: '*',
          filter: `metadata.namespace = "${namespace}"`,
          limit: 10
        })
        results.namespaceSearch = {
          count: namespaceSearch.length,
          items: namespaceSearch
        }
        console.log('[FIRESTARTER-DEBUG] Namespace search found:', namespaceSearch.length, 'items')
      } catch (e) {
        console.error('[FIRESTARTER-DEBUG] Namespace search error:', e)
        results.namespaceSearchError = e instanceof Error ? e.message : String(e)
      }
    }
    
    // 2. Search without filter
    try {
      const allSearch = await searchIndex.search({
        query: namespace || 'test',
        limit: 10
      })
      results.allSearch = {
        count: allSearch.length,
        items: allSearch
      }
      console.log('[FIRESTARTER-DEBUG] All search found:', allSearch.length, 'items')
    } catch (e) {
      console.error('[FIRESTARTER-DEBUG] All search error:', e)
      results.allSearchError = e instanceof Error ? e.message : String(e)
    }
    
    // 3. Try semantic search
    try {
      const semanticSearch = await searchIndex.search({
        query: 'homepage website content',
        limit: 10
      })
      results.semanticSearch = {
        count: semanticSearch.length,
        items: semanticSearch
      }
      console.log('[FIRESTARTER-DEBUG] Semantic search found:', semanticSearch.length, 'items')
    } catch (e) {
      console.error('[FIRESTARTER-DEBUG] Semantic search error:', e)
      results.semanticSearchError = e instanceof Error ? e.message : String(e)
    }
    
    return NextResponse.json({
      success: true,
      namespace: namespace,
      results: results,
      upstashUrl: process.env.UPSTASH_SEARCH_REST_URL ? 'Configured' : 'Not configured',
      upstashToken: process.env.UPSTASH_SEARCH_REST_TOKEN ? 'Configured' : 'Not configured'
    })
  } catch (error) {
    console.error('[FIRESTARTER-DEBUG] Error:', error)
    return NextResponse.json(
      { 
        error: 'Debug endpoint error',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}

================
File: app/api/firestarter/query/route.ts
================
import { NextRequest } from 'next/server'
import { groq } from '@ai-sdk/groq'
import { streamText } from 'ai'
import { searchIndex } from '@/lib/upstash-search'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    // Handle both direct query format and useChat format
    let query = body.query
    let namespace = body.namespace
    let stream = body.stream ?? false
    
    // If using useChat format, extract query from messages
    if (!query && body.messages && Array.isArray(body.messages)) {
      const lastUserMessage = body.messages.filter((m: any) => m.role === 'user').pop()
      query = lastUserMessage?.content
    }
    
    if (!query || !namespace) {
      return new Response(
        JSON.stringify({ error: 'Query and namespace are required' }), 
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      )
    }

    console.log('[FIRESTARTER-QUERY] Namespace:', namespace)
    console.log('[FIRESTARTER-QUERY] Query:', query)
    
    // Retrieve documents from Upstash Search
    interface SearchDocument {
      content?: {
        text?: string  // Searchable text
      }
      metadata?: {
        namespace?: string
        title?: string
        pageTitle?: string
        url?: string
        sourceURL?: string
        description?: string
        fullContent?: string  // Full content stored here
      }
      score?: number
    }
    
    let documents: SearchDocument[] = []
    
    try {
      // Search for documents - include namespace to improve relevance
      console.log('[FIRESTARTER-QUERY] Searching for documents with query:', query)
      
      // Include namespace in search to boost relevance
      const searchQuery = `${query} ${namespace}`
      
      const searchResults = await searchIndex.search({
        query: searchQuery,
        limit: 100
      })
      
      console.log('[FIRESTARTER-QUERY] Initial search found:', searchResults.length, 'results')
      
      // Filter to only include documents from the correct namespace
      documents = searchResults.filter((doc) => {
        const docNamespace = doc.metadata?.namespace
        const matches = docNamespace === namespace
        if (!matches && doc.metadata?.namespace) {
          // Only log first few mismatches to avoid spam
          if (documents.length < 3) {
            console.log('[FIRESTARTER-QUERY] Namespace mismatch:', doc.metadata.namespace, '!==', namespace)
          }
        }
        return matches
      })
      
      console.log('[FIRESTARTER-QUERY] After namespace filter:', documents.length, 'documents')
      
      // If no results, try searching just for documents in this namespace
      if (documents.length === 0) {
        console.log('[FIRESTARTER-QUERY] No results found, trying fallback search')
        
        const fallbackResults = await searchIndex.search({
          query: namespace,
          limit: 100
        })
        
        console.log('[FIRESTARTER-QUERY] Fallback search found:', fallbackResults.length, 'results')
        
        // Filter for exact namespace match
        const namespaceDocs = fallbackResults.filter((doc) => {
          return doc.metadata?.namespace === namespace
        })
        
        console.log('[FIRESTARTER-QUERY] Namespace documents found:', namespaceDocs.length)
        
        // If we found documents in the namespace, search within their content
        if (namespaceDocs.length > 0) {
          // Score documents based on query relevance
          const queryLower = query.toLowerCase()
          documents = namespaceDocs.filter((doc) => {
            const content = (doc.content?.text || '').toLowerCase()
            const title = (doc.content?.title || '').toLowerCase()
            const url = (doc.content?.url || '').toLowerCase()
            
            return content.includes(queryLower) || 
                   title.includes(queryLower) || 
                   url.includes(queryLower)
          })
          
          console.log('[FIRESTARTER-QUERY] Content-filtered documents:', documents.length)
          
          // If still no results, return all namespace documents
          if (documents.length === 0) {
            documents = namespaceDocs
          }
        }
      }
      
    } catch (searchError) {
      console.error('[FIRESTARTER-QUERY] Search failed:', searchError)
      documents = []
    }
    
    // Check if we have any data for this namespace
    if (documents.length === 0) {
      console.log('[FIRESTARTER-QUERY] No documents found for namespace:', namespace)
      
      const answer = `I don't have any indexed content for this website. Please make sure the website has been crawled first.`
      const sources: never[] = []
      
      if (stream) {
        // Create a simple text stream for the answer
        const result = await streamText({
          model: groq('meta-llama/llama-4-scout-17b-16e-instruct'),
          prompt: answer,
          maxTokens: 1,
          temperature: 0,
        })
        
        return result.toDataStreamResponse()
      } else {
        return new Response(
          JSON.stringify({ answer, sources }), 
          { headers: { 'Content-Type': 'application/json' } }
        )
      }
    }

    const groqApiKey = process.env.GROQ_API_KEY
    if (!groqApiKey) {
      console.error('[FIRESTARTER-QUERY] GROQ_API_KEY is not set!')
      const answer = 'AI service is not configured. Please set GROQ_API_KEY in your environment variables.'
      return new Response(
        JSON.stringify({ answer, sources: [] }), 
        { headers: { 'Content-Type': 'application/json' } }
      )
    }
    
    // Transform Upstash search results to expected format
    interface TransformedDocument {
      content: string
      url: string
      title: string
      description: string
      score: number
    }
    
    const transformedDocuments: TransformedDocument[] = documents.map((result) => {
      const title = result.metadata?.title || result.metadata?.pageTitle || 'Untitled'
      const description = result.metadata?.description || ''
      const url = result.metadata?.url || result.metadata?.sourceURL || ''
      
      // Get content from the document - prefer full content from metadata, fallback to searchable text
      const rawContent = result.metadata?.fullContent || result.content?.text || ''
      
      if (!rawContent) {
        console.warn('[FIRESTARTER-QUERY] Document has no content:', { 
          url, 
          title,
          hasContent: !!result.content,
          hasFullContent: !!result.metadata?.fullContent,
          contentKeys: result.content ? Object.keys(result.content) : [],
          metadataKeys: result.metadata ? Object.keys(result.metadata) : []
        })
      }
      
      // Create structured content with clear metadata headers
      const structuredContent = `TITLE: ${title}
DESCRIPTION: ${description}
SOURCE: ${url}

${rawContent}`
      
      return {
        content: structuredContent,
        url: url,
        title: title,
        description: description,
        score: result.score || 0
      }
    })
    
    // Documents from Upstash are already scored by relevance
    // Sort by score and take top results
    const relevantDocs = transformedDocuments
      .sort((a, b) => (b.score || 0) - (a.score || 0))
      .slice(0, 20) // Get many more sources for better coverage
    
    console.log('[FIRESTARTER-QUERY] Found relevant docs:', relevantDocs.length, 'from', transformedDocuments.length, 'total')
    
    // If no matches, use more documents as context
    const docsToUse = relevantDocs.length > 0 ? relevantDocs : transformedDocuments.slice(0, 10)

    // Build context from relevant documents - use more content for better answers
    const contextDocs = docsToUse.slice(0, 10) // Use top 10 for richer context
    
    // Log document structure for debugging
    if (contextDocs.length > 0) {
      console.log('[FIRESTARTER-QUERY] Sample document for context:', {
        url: contextDocs[0].url,
        title: contextDocs[0].title,
        contentLength: contextDocs[0].content?.length || 0,
        hasContent: !!contextDocs[0].content
      })
    }
    
    const context = contextDocs
      .map((doc) => {
        const content = doc.content || ''
        if (!content) {
          console.warn('[FIRESTARTER-QUERY] Empty content for doc:', doc.url)
          return null
        }
        return content.substring(0, 1500) + '...'
      })
      .filter(Boolean)
      .join('\n\n---\n\n')
    
    console.log('[FIRESTARTER-QUERY] Context length:', context.length, 'chars')
    console.log('[FIRESTARTER-QUERY] Using', contextDocs.length, 'docs for context,', docsToUse.length, 'total sources')
    
    // If context is empty, log error
    if (!context || context.length < 100) {
      console.error('[FIRESTARTER-QUERY] Context too short or empty!', { contextLength: context.length })
      
      const answer = 'I found some relevant pages but couldn\'t extract enough content to answer your question. This might be due to the way the pages were crawled. Try crawling the website again with a higher page limit.'
      const sources = docsToUse.map((doc) => ({
        url: doc.url,
        title: doc.title,
        snippet: (doc.content || '').substring(0, 200) + '...'
      }))
      
      return new Response(
        JSON.stringify({ answer, sources }), 
        { headers: { 'Content-Type': 'application/json' } }
      )
    }

    // Prepare sources
    const sources = docsToUse.map((doc) => ({
      url: doc.url,
      title: doc.title,
      snippet: (doc.content || '').substring(0, 200) + '...'
    }))

    // Generate response using Vercel AI SDK
    try {
      console.log('[FIRESTARTER-QUERY] Calling Groq API...', { streaming: stream })
      
      const systemPrompt = `You are a helpful assistant that answers questions based ONLY on the provided context from a website. 
IMPORTANT: You MUST use the information provided in the context below to answer the user's question.
- Answer questions comprehensively using ONLY the context provided
- DO NOT use any external knowledge - only what's in the context
- Use bullet points or numbered lists when appropriate for clarity
- Cite specific information from the sources when relevant
- If the context doesn't contain enough information to answer the question, say so explicitly
- Be concise but thorough`

      const userPrompt = `Question: ${query}\n\nRelevant content from the website:\n${context}\n\nPlease provide a comprehensive answer based on this information.`

      console.log('[FIRESTARTER-QUERY] System prompt:', systemPrompt.substring(0, 100) + '...')
      console.log('[FIRESTARTER-QUERY] User prompt length:', userPrompt.length)
      console.log('[FIRESTARTER-QUERY] User prompt preview:', userPrompt.substring(0, 500) + '...')
      
      // Log a sample of the actual content being sent
      if (contextDocs.length > 0) {
        console.log('[FIRESTARTER-QUERY] First document full content preview:')
        console.log(contextDocs[0].content.substring(0, 500) + '...')
      }

      if (stream) {
        // Stream the response using Groq with Llama 4 Scout
        const result = await streamText({
          model: groq('meta-llama/llama-4-scout-17b-16e-instruct'),
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt }
          ],
          temperature: 0.7,
          maxTokens: 800,
        })
        
        // Return the stream response with additional data
        return result.toDataStreamResponse()
      } else {
        // Non-streaming response
        const result = await streamText({
          model: groq('meta-llama/llama-4-scout-17b-16e-instruct'),
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt }
          ],
          temperature: 0.7,
          maxTokens: 800
        })
        
        // Get the full text
        let answer = ''
        for await (const textPart of result.textStream) {
          answer += textPart
        }
        
        return new Response(
          JSON.stringify({ answer, sources }), 
          { headers: { 'Content-Type': 'application/json' } }
        )
      }
      
    } catch (groqError) {
      console.error('[FIRESTARTER-QUERY] Groq API error:', groqError)
      
      const errorMessage = groqError instanceof Error ? groqError.message : 'Unknown error'
      let answer = `Error generating response: ${errorMessage}`
      
      if (errorMessage.includes('401') || errorMessage.includes('Unauthorized')) {
        answer = 'Error: Groq API authentication failed. Please check your GROQ_API_KEY.'
      } else if (errorMessage.includes('rate limit')) {
        answer = 'Error: Groq API rate limit exceeded. Please try again later.'
      }
      
      return new Response(
        JSON.stringify({ answer, sources }), 
        { headers: { 'Content-Type': 'application/json' } }
      )
    }
  } catch (error) {
    console.error('Error in firestarter query route:', error)
    return new Response(
      JSON.stringify({ error: 'Failed to process query' }), 
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    )
  }
}

================
File: app/api/indexes/route.ts
================
import { NextRequest, NextResponse } from 'next/server'
import { getIndexes, saveIndex, deleteIndex, IndexMetadata } from '@/lib/storage'

export async function GET() {
  try {
    const indexes = await getIndexes()
    return NextResponse.json({ indexes })
  } catch (error) {
    console.error('Error fetching indexes:', error)
    return NextResponse.json({ error: 'Failed to fetch indexes' }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const index: IndexMetadata = await request.json()
    await saveIndex(index)
    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error saving index:', error)
    return NextResponse.json({ error: 'Failed to save index' }, { status: 500 })
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const namespace = searchParams.get('namespace')
    
    if (!namespace) {
      return NextResponse.json({ error: 'Namespace is required' }, { status: 400 })
    }
    
    await deleteIndex(namespace)
    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error deleting index:', error)
    return NextResponse.json({ error: 'Failed to delete index' }, { status: 500 })
  }
}

================
File: app/api/scrape/route.ts
================
import { NextRequest, NextResponse } from 'next/server';
import FirecrawlApp from '@mendable/firecrawl-js';
import { isRateLimited } from '@/lib/rate-limit';

interface ScrapeRequestBody {
  url?: string;
  urls?: string[];
  [key: string]: unknown;
}

interface ScrapeResult {
  success: boolean;
  data?: Record<string, unknown>;
  error?: string;
}

interface ApiError extends Error {
  status?: number;
}

export async function POST(request: NextRequest) {
  const rateLimit = await isRateLimited(request, 'scrape');
  
  if (!rateLimit.success) {
    return NextResponse.json({ 
      success: false,
      error: 'Rate limit exceeded. Please try again later.' 
    }, { 
      status: 429,
      headers: {
        'X-RateLimit-Limit': rateLimit.limit.toString(),
        'X-RateLimit-Remaining': rateLimit.remaining.toString(),
      }
    });
  }

  let apiKey = process.env.FIRECRAWL_API_KEY;
  
  if (!apiKey) {
    const headerApiKey = request.headers.get('X-Firecrawl-API-Key');
    
    if (!headerApiKey) {
      return NextResponse.json({ 
        success: false, 
        error: 'API configuration error. Please try again later or contact support.' 
      }, { status: 500 });
    }
    
    apiKey = headerApiKey;
  }

  try {
    const app = new FirecrawlApp({ apiKey });
    const body = await request.json() as ScrapeRequestBody;
    const { url, urls, ...params } = body;

    let result: ScrapeResult;

    if (url && typeof url === 'string') {
      result = await app.scrapeUrl(url, params) as ScrapeResult;
    } else if (urls && Array.isArray(urls)) {
      result = await app.batchScrapeUrls(urls, params) as ScrapeResult;
    } else {
      return NextResponse.json({ success: false, error: 'Invalid request format. Please check your input and try again.' }, { status: 400 });
    }
    
    return NextResponse.json(result);

  } catch (error: unknown) {
    console.error('Error in /api/scrape endpoint (SDK):', error);
    const err = error as ApiError;
    const errorStatus = typeof err.status === 'number' ? err.status : 500;
    return NextResponse.json({ success: false, error: 'An error occurred while processing your request. Please try again later.' }, { status: errorStatus });
  }
}

================
File: app/api/v1/chat/completions/route.ts
================
import { NextRequest, NextResponse } from 'next/server'

// CORS headers for API access
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Use-Groq, X-Use-OpenAI',
      'Access-Control-Max-Age': '86400',
    },
  })
}

// OpenAI-compatible chat completions endpoint
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { messages, model, stream = false } = body
    
    // Check if this is a Groq API request
    const useGroq = request.headers.get('X-Use-Groq') === 'true'
    const useOpenAI = request.headers.get('X-Use-OpenAI') === 'true'
    
    if (useGroq) {
      // Handle Groq API request
      const groqApiKey = process.env.GROQ_API_KEY
      
      if (!groqApiKey) {
        return NextResponse.json(
          { 
            error: {
              message: 'Groq API key not configured',
              type: 'server_error',
              code: 500
            }
          },
          { status: 500 }
        )
      }
      
      // Forward request to Groq API
      const groqResponse = await fetch('https://api.groq.com/openai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${groqApiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          messages,
          model,
          stream,
          temperature: body.temperature || 0.7,
          max_tokens: body.max_tokens || 2000
        })
      })
      
      if (!groqResponse.ok) {
        const errorData = await groqResponse.json()
        throw new Error(errorData.error?.message || 'Groq API error')
      }
      
      const groqData = await groqResponse.json()
      
      return NextResponse.json(groqData, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Use-Groq, X-Use-OpenAI',
        }
      })
    }
    
    if (useOpenAI) {
      // Handle OpenAI API request with follow-up questions
      const openaiApiKey = process.env.OPENAI_API_KEY
      
      if (!openaiApiKey) {
        return NextResponse.json(
          { 
            error: {
              message: 'OpenAI API key not configured',
              type: 'server_error',
              code: 500
            }
          },
          { status: 500 }
        )
      }
      
      // First, get the main response
      const openaiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${openaiApiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          messages,
          model,
          stream,
          temperature: body.temperature || 0.7,
          max_tokens: body.max_tokens || 2000
        })
      })
      
      if (!openaiResponse.ok) {
        const errorData = await openaiResponse.json()
        throw new Error(errorData.error?.message || 'OpenAI API error')
      }
      
      const openaiData = await openaiResponse.json()
      
      // Generate follow-up questions
      const lastUserMessage = messages.filter((m: { role: string }) => m.role === 'user').pop()
      const assistantResponse = openaiData.choices[0].message.content
      
      const followUpResponse = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${openaiApiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          messages: [
            {
              role: 'system',
              content: 'Generate 3 relevant follow-up questions based on the query and answer. Return only the questions, one per line, no numbering or bullets.'
            },
            {
              role: 'user',
              content: `Original query: "${lastUserMessage?.content}"\n\nAnswer summary: ${assistantResponse.slice(0, 1000)}...\n\nGenerate 3 follow-up questions that explore different aspects or dig deeper into the topic.`
            }
          ],
          model: 'gpt-4o-mini',
          temperature: 0.8,
          max_tokens: 200
        })
      })
      
      if (followUpResponse.ok) {
        const followUpData = await followUpResponse.json()
        const followUpText = followUpData.choices[0].message.content
        const followUpQuestions = followUpText
          .split('\n')
          .map((q: string) => q.trim())
          .filter((q: string) => q.length > 0)
          .slice(0, 3)
        
        // Add follow-up questions to the response
        openaiData.follow_up_questions = followUpQuestions
      }
      
      return NextResponse.json(openaiData, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Use-Groq, X-Use-OpenAI',
        }
      })
    }
    
    // Original Firecrawl namespace logic
    let namespace = ''
    
    if (model?.startsWith('firecrawl-')) {
      // Extract the domain part after "firecrawl-"
      const domainPart = model.substring('firecrawl-'.length)
      // For now, we'll need to look up the actual namespace based on the domain
      // This is a simplified version - in production you'd want to store a mapping
      namespace = domainPart
    }
    
    if (!namespace) {
      return NextResponse.json(
        { 
          error: {
            message: 'Invalid model specified. Use format: firecrawl-<domain>',
            type: 'invalid_request_error',
            code: 400
          }
        },
        { status: 400 }
      )
    }

    // Get the last user message for context search
    interface Message {
      role: string
      content: string
    }
    
    const lastUserMessage = messages.filter((m: Message) => m.role === 'user').pop()
    const query = lastUserMessage?.content || ''

    // Call the firestarter query endpoint
    const contextResponse = await fetch(`${request.nextUrl.origin}/api/firestarter/query`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        query, 
        namespace,
        messages: messages.slice(0, -1) // Previous messages for context
      })
    })

    const contextData = await contextResponse.json()
    
    if (!contextResponse.ok) {
      throw new Error(contextData.error || 'Failed to retrieve context')
    }

    // Format the response in OpenAI format
    const completion = {
      id: `chatcmpl-${Date.now()}`,
      object: 'chat.completion',
      created: Math.floor(Date.now() / 1000),
      model: model,
      choices: [
        {
          index: 0,
          message: {
            role: 'assistant',
            content: contextData.answer
          },
          finish_reason: 'stop'
        }
      ]
    }

    // Add sources as metadata if available
    if (contextData.sources && contextData.sources.length > 0) {
      interface Source {
        title: string
        url: string
      }
      
      completion.choices[0].message.content += `\n\n**Sources:**\n${contextData.sources.map((s: Source) => `- [${s.title}](${s.url})`).join('\n')}`
    }

    return NextResponse.json(completion, {
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      }
    })
  } catch (error) {
    console.error('Error in OpenAI-compatible endpoint:', error)
    return NextResponse.json(
      { 
        error: {
          message: error instanceof Error ? error.message : 'Failed to process chat completion',
          type: 'server_error',
          code: 500
        }
      },
      { 
        status: 500,
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Use-Groq, X-Use-OpenAI',
        }
      }
    )
  }
}

================
File: app/dashboard/page.tsx
================
'use client'

import { useState, useEffect, useRef } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Send, Globe, Copy, Check, AlertCircle, FileText, Database, ArrowLeft, ExternalLink } from 'lucide-react'
import Image from 'next/image'
// Removed useChat - using custom implementation
import { toast } from "sonner"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"

interface Source {
  url: string
  title: string
  snippet: string
}

interface SiteData {
  url: string
  namespace: string
  pagesCrawled: number
  metadata: {
    title: string
    description: string
    favicon?: string
    ogImage?: string
  }
  crawlId?: string
  crawlComplete?: boolean
  crawlDate?: string
}

// Simple markdown renderer component
function MarkdownContent({ content, onSourceClick, isStreaming = false }: { content: string; onSourceClick?: (index: number) => void; isStreaming?: boolean }) {
  // Simple markdown parsing
  const parseMarkdown = (text: string) => {
    // First, handle code blocks to prevent other parsing inside them
    const codeBlocks: string[] = [];
    let parsed = text.replace(/```([\s\S]*?)```/g, (_, code) => {
      const placeholder = `__CODE_BLOCK_${codeBlocks.length}__`;
      codeBlocks.push(`<pre class="bg-gray-50 border border-gray-200 p-4 rounded-lg overflow-x-auto my-4 text-sm"><code>${code.trim()}</code></pre>`);
      return placeholder;
    });
    
    // Handle inline code
    parsed = parsed.replace(/`([^`]+)`/g, '<code class="bg-orange-50 text-orange-600 px-1.5 py-0.5 rounded text-sm font-mono">$1</code>');
    
    // Handle links [text](url) - must come before citations
    parsed = parsed.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer" class="text-orange-600 hover:text-orange-700 underline">$1</a>');
    
    // Handle citations [1], [2], etc.
    parsed = parsed.replace(/\[(\d+)\]/g, (_, num) => {
      return `<sup class="citation text-orange-600 cursor-pointer hover:text-orange-700 font-medium" data-citation="${num}">[${num}]</sup>`;
    });
    
    // Bold text
    parsed = parsed.replace(/\*\*(.+?)\*\*/g, '<strong class="font-semibold text-gray-900">$1</strong>');
    
    // Italic text  
    parsed = parsed.replace(/\*(.+?)\*/g, '<em>$1</em>');
    
    // Split into lines for processing
    const lines = parsed.split('\n');
    const processedLines = [];
    let inList = false;
    let listType = '';
    let inParagraph = false;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      const nextLine = i < lines.length - 1 ? lines[i + 1].trim() : '';
      
      // Headers
      if (line.match(/^#{1,3}\s/)) {
        if (inParagraph) {
          processedLines.push('</p>');
          inParagraph = false;
        }
        if (line.match(/^###\s(.+)$/)) {
          processedLines.push(line.replace(/^###\s(.+)$/, '<h3 class="text-base font-semibold mt-4 mb-2 text-gray-900">$1</h3>'));
        } else if (line.match(/^##\s(.+)$/)) {
          processedLines.push(line.replace(/^##\s(.+)$/, '<h2 class="text-lg font-semibold mt-5 mb-3 text-gray-900">$1</h2>'));
        } else if (line.match(/^#\s(.+)$/)) {
          processedLines.push(line.replace(/^#\s(.+)$/, '<h1 class="text-xl font-bold mt-6 mb-3 text-gray-900">$1</h1>'));
        }
        continue;
      }
      
      // Lists
      const bulletMatch = line.match(/^[-*]\s(.+)$/);
      const numberedMatch = line.match(/^(\d+)\.\s(.+)$/);
      
      if (bulletMatch || numberedMatch) {
        if (inParagraph) {
          processedLines.push('</p>');
          inParagraph = false;
        }
        
        const newListType = bulletMatch ? 'ul' : 'ol';
        if (!inList) {
          listType = newListType;
          processedLines.push(`<${listType} class="${listType === 'ul' ? 'list-disc' : 'list-decimal'} ml-6 my-3 space-y-1">`);
          inList = true;
        } else if (listType !== newListType) {
          processedLines.push(`</${listType}>`);
          listType = newListType;
          processedLines.push(`<${listType} class="${listType === 'ul' ? 'list-disc' : 'list-decimal'} ml-6 my-3 space-y-1">`);
        }
        
        const content = bulletMatch ? bulletMatch[1] : numberedMatch![2];
        processedLines.push(`<li class="text-gray-700 leading-relaxed">${content}</li>`);
        continue;
      } else if (inList && line === '') {
        processedLines.push(`</${listType}>`);
        inList = false;
        continue;
      }
      
      // Empty lines
      if (line === '') {
        if (inParagraph) {
          processedLines.push('</p>');
          inParagraph = false;
        }
        if (inList) {
          processedLines.push(`</${listType}>`);
          inList = false;
        }
        continue;
      }
      
      // Regular text - start new paragraph if needed
      if (!inParagraph && !inList && !line.startsWith('<')) {
        processedLines.push('<p class="text-gray-700 leading-relaxed mb-3">');
        inParagraph = true;
      }
      
      // Add line with space if in paragraph
      if (inParagraph) {
        processedLines.push(line + (nextLine && !nextLine.match(/^[-*#]|\d+\./) ? ' ' : ''));
      } else {
        processedLines.push(line);
      }
    }
    
    // Close any open tags
    if (inParagraph) {
      processedLines.push('</p>');
    }
    if (inList) {
      processedLines.push(`</${listType}>`);
    }
    
    parsed = processedLines.join('\n');
    
    // Restore code blocks
    codeBlocks.forEach((block, index) => {
      parsed = parsed.replace(`__CODE_BLOCK_${index}__`, block);
    });
    
    return parsed;
  };

  useEffect(() => {
    // Add click handlers for citations
    const citations = document.querySelectorAll('.citation');
    citations.forEach(citation => {
      citation.addEventListener('click', (e) => {
        const citationNum = parseInt((e.target as HTMLElement).getAttribute('data-citation') || '0');
        if (onSourceClick && citationNum > 0) {
          onSourceClick(citationNum - 1);
        }
      });
    });

    return () => {
      citations.forEach(citation => {
        citation.removeEventListener('click', () => {});
      });
    };
  }, [content, onSourceClick]);

  return (
    <div className="relative">
      <div 
        className="prose prose-sm max-w-none prose-gray prose-headings:text-gray-900 prose-p:text-gray-700 prose-strong:text-gray-900 prose-code:text-orange-600 prose-code:bg-orange-50 prose-code:px-1 prose-code:py-0.5 prose-code:rounded prose-pre:bg-gray-100 prose-pre:text-gray-800 prose-li:text-gray-700 prose-a:text-orange-600 prose-a:no-underline hover:prose-a:underline"
        dangerouslySetInnerHTML={{ __html: parseMarkdown(content) }}
      />
      {isStreaming && (
        <span className="inline-block w-1 h-4 bg-gray-600 animate-pulse ml-1" />
      )}
    </div>
  );
}

export default function DashboardPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const [siteData, setSiteData] = useState<SiteData | null>(null)
  const [showDeleteModal, setShowDeleteModal] = useState(false)
  const [copiedItem, setCopiedItem] = useState<string | null>(null)
  const [messages, setMessages] = useState<Array<{ role: 'user' | 'assistant'; content: string; sources?: Source[] }>>([])
  const [input, setInput] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [showApiModal, setShowApiModal] = useState(false)
  const [activeTab, setActiveTab] = useState<'curl' | 'javascript' | 'python'>('curl')
  const scrollAreaRef = useRef<HTMLDivElement>(null)

  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!input.trim() || !siteData) return

    let processedInput = input.trim()
    
    // Check if the input looks like a URL without protocol
    const urlPattern = /^(?!https?:\/\/)([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(\/.*)?$/
    if (urlPattern.test(processedInput)) {
      processedInput = 'https://' + processedInput
    }

    const userMessage = { role: 'user' as const, content: processedInput }
    setMessages(prev => [...prev, userMessage])
    setInput('')
    setIsLoading(true)
    
    try {
      const response = await fetch('/api/firestarter/query', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          messages: [userMessage],
          namespace: siteData.namespace,
          stream: true
        })
      })

      if (!response.ok) {
        throw new Error('Failed to get response')
      }

      const reader = response.body?.getReader()
      const decoder = new TextDecoder()
      let sources: Source[] = []
      let content = ''
      let hasStartedStreaming = false

      if (!reader) throw new Error('No response body')

      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        const chunk = decoder.decode(value)
        const lines = chunk.split('\n')

        for (const line of lines) {
          if (line.trim() === '') continue
          
          // Handle Vercel AI SDK streaming format
          if (line.startsWith('0:')) {
            // Text content chunk
            const textContent = line.slice(2)
            if (textContent.startsWith('"') && textContent.endsWith('"')) {
              const text = JSON.parse(textContent)
              content += text
              
              // Add assistant message on first content
              if (!hasStartedStreaming) {
                hasStartedStreaming = true
                setMessages(prev => [...prev, { 
                  role: 'assistant' as const, 
                  content: content, 
                  sources: sources 
                }])
              } else {
                // Update the last message with new content
                setMessages(prev => {
                  const newMessages = [...prev]
                  const lastMessage = newMessages[newMessages.length - 1]
                  if (lastMessage && lastMessage.role === 'assistant') {
                    lastMessage.content = content
                    lastMessage.sources = sources
                  }
                  return newMessages
                })
              }
              scrollToBottom()
            }
          } else if (line.startsWith('8:')) {
            // Streaming data chunk (sources, etc)
            try {
              const jsonStr = line.slice(2)
              const data = JSON.parse(jsonStr)
              console.log('[Dashboard] Stream data:', data)
              
              if (Array.isArray(data)) {
                // This might be our sources
                const sourcesData = data.find(item => item && typeof item === 'object' && 'type' in item && item.type === 'sources')
                if (sourcesData && sourcesData.sources) {
                  sources = sourcesData.sources
                }
              }
            } catch (e) {
              console.log('[Dashboard] Could not parse stream data:', line)
            }
          } else if (line.startsWith('e:') || line.startsWith('d:')) {
            // End metadata - we can ignore these
            console.log('[Dashboard] Stream ended')
          }
        }
      }
    } catch (error) {
      console.error('Chat error:', error)
      toast.error('Failed to get response')
    } finally {
      setIsLoading(false)
    }
  }

  useEffect(() => {
    // Get namespace from URL params
    const namespaceParam = searchParams.get('namespace')
    console.log('[Dashboard] Loading with namespace:', namespaceParam)
    
    if (namespaceParam) {
      // Try to load data for this specific namespace
      const storedIndexes = localStorage.getItem('firestarter_indexes')
      if (storedIndexes) {
        const indexes = JSON.parse(storedIndexes)
        const matchingIndex = indexes.find((idx: any) => idx.namespace === namespaceParam)
        if (matchingIndex) {
          console.log('[Dashboard] Found matching index:', matchingIndex)
          setSiteData(matchingIndex)
          // Also update sessionStorage for consistency
          sessionStorage.setItem('firestarter_current_data', JSON.stringify(matchingIndex))
          // Clear messages when namespace changes
          setMessages([])
        } else {
          // Namespace not found in stored indexes
          router.push('/indexes')
        }
      } else {
        router.push('/indexes')
      }
    } else {
      // Fallback to sessionStorage if no namespace param
      const data = sessionStorage.getItem('firestarter_current_data')
      if (data) {
        const parsedData = JSON.parse(data)
        setSiteData(parsedData)
        // Add namespace to URL for consistency
        router.replace(`/dashboard?namespace=${parsedData.namespace}`)
      } else {
        router.push('/indexes')
      }
    }
  }, [router, searchParams])

  const scrollToBottom = () => {
    if (scrollAreaRef.current) {
      scrollAreaRef.current.scrollTo({
        top: scrollAreaRef.current.scrollHeight,
        behavior: 'smooth'
      })
    }
  }

  const handleDelete = () => {
    // Remove from localStorage
    const storedIndexes = localStorage.getItem('firestarter_indexes')
    if (storedIndexes && siteData) {
      const indexes = JSON.parse(storedIndexes)
      const updatedIndexes = indexes.filter((idx: any) => idx.namespace !== siteData.namespace)
      localStorage.setItem('firestarter_indexes', JSON.stringify(updatedIndexes))
    }
    
    sessionStorage.removeItem('firestarter_current_data')
    router.push('/indexes')
  }

  const copyToClipboard = (text: string, itemId: string) => {
    navigator.clipboard.writeText(text)
    setCopiedItem(itemId)
    setTimeout(() => setCopiedItem(null), 2000)
  }


  if (!siteData) {
    console.log('[Dashboard] No siteData, showing loading...')
    return (
      <div className="min-h-screen bg-[#FBFAF9] flex items-center justify-center">
        <div className="text-gray-600">Loading...</div>
      </div>
    )
  }
  
  console.log('[Dashboard] Rendering with siteData:', siteData)

  const modelName = `firecrawl-${siteData.namespace}`
  
  // Check if we're in development mode
  const isDev = process.env.NODE_ENV === 'development' || (typeof window !== 'undefined' && window.location.hostname === 'localhost')
  const apiUrl = isDev ? 'http://localhost:3001/api/v1/chat/completions' : 'https://tools.firecrawl.dev/api/v1/chat/completions'
  
  const curlCommand = `curl ${apiUrl} \\
  -H "Content-Type: application/json" \\
  -H "Authorization: Bearer YOUR_FIRESTARTER_API_KEY" \\
  -d '{
    "model": "${modelName}",
    "messages": [
      {"role": "user", "content": "Your question here"}
    ]
  }'`
  
  const jsCode = `// Using fetch API
const response = await fetch('${apiUrl}', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer YOUR_FIRESTARTER_API_KEY'
  },
  body: JSON.stringify({
    model: '${modelName}',
    messages: [
      { role: 'user', content: 'Your question here' }
    ]
  })
});

const data = await response.json();
console.log(data.choices[0].message.content);`
  
  const pythonCode = `import requests

response = requests.post(
    '${apiUrl}',
    headers={
        'Content-Type': 'application/json',
        'Authorization': 'Bearer YOUR_FIRESTARTER_API_KEY'
    },
    json={
        'model': '${modelName}',
        'messages': [
            {'role': 'user', 'content': 'Your question here'}
        ]
    }
)

data = response.json()
print(data['choices'][0]['message']['content'])`
  

  return (
    <div className="min-h-screen bg-[#FBFAF9]">
      {/* Header */}
      <div className="border-b border-gray-200 bg-white">
        <div className="max-w-7xl mx-auto px-4 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4">
              <button
                onClick={() => router.push('/indexes')}
                className="p-2 hover:bg-gray-100 rounded-lg transition-colors"
              >
                <ArrowLeft className="w-5 h-5 text-gray-600" />
              </button>
              <div className="flex items-center gap-3">
                {siteData.metadata.favicon ? (
                  <Image 
                    src={siteData.metadata.favicon} 
                    alt={siteData.metadata.title}
                    width={32}
                    height={32}
                    className="w-8 h-8"
                    onError={(e) => {
                      e.currentTarget.style.display = 'none';
                      e.currentTarget.parentElement?.querySelector('.fallback-icon')?.classList.remove('hidden');
                    }}
                  />
                ) : (
                  <div className="w-8 h-8 bg-gray-100 rounded-lg flex items-center justify-center">
                    <Globe className="w-5 h-5 text-gray-400" />
                  </div>
                )}
                <div>
                  <h1 className="text-xl font-semibold text-[#36322F]">
                    {siteData.metadata.title.length > 50 
                      ? siteData.metadata.title.substring(0, 47) + '...' 
                      : siteData.metadata.title}
                  </h1>
                  <p className="text-sm text-gray-600">{siteData.url}</p>
                </div>
              </div>
            </div>
            
            <Button
              onClick={() => setShowDeleteModal(true)}
              variant="outline"
              size="sm"
              className="text-black hover:text-gray-700 hover:bg-gray-50 border-gray-300"
            >
              Delete
            </Button>
          </div>
        </div>
      </div>

      <div className="max-w-7xl mx-auto px-4 py-6">
        <div className="flex flex-col lg:flex-row gap-6 h-[600px]">
          {/* Stats Cards */}
          <div className="lg:w-1/4 flex flex-col gap-4 h-full">
            <div className="relative bg-white rounded-xl border border-gray-200 overflow-hidden flex-1">
              {/* OG Image Background */}
              {siteData.metadata.ogImage && (
                <div className="absolute inset-0 z-0">
                  <Image 
                    src={siteData.metadata.ogImage} 
                    alt=""
                    fill
                    className="object-contain opacity-30"
                    onError={(e) => {
                      e.currentTarget.parentElement!.style.display = 'none';
                    }}
                  />
                  <div className="absolute inset-0 bg-gradient-to-br from-white/70 via-white/60 to-white/70"></div>
                </div>
              )}
              
              <div className="relative z-10 p-6 h-full flex flex-col">
                <div className="mb-4">
                  <h2 className="text-lg font-semibold text-[#36322F]">
                    {siteData.metadata.title.length > 30 
                      ? siteData.metadata.title.substring(0, 27) + '...' 
                      : siteData.metadata.title}
                  </h2>
                  <p className="text-xs text-gray-600">Knowledge Base</p>
                </div>
                
                <div className="space-y-2 flex-1">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2 text-gray-700">
                      <FileText className="w-4 h-4" />
                      <span className="text-sm font-medium">Pages</span>
                    </div>
                    <span className="text-lg font-semibold text-[#36322F]">{siteData.pagesCrawled}</span>
                  </div>
                  
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2 text-gray-700">
                      <Database className="w-4 h-4" />
                      <span className="text-sm font-medium">Chunks</span>
                    </div>
                    <span className="text-lg font-semibold text-[#36322F]">{Math.round(siteData.pagesCrawled * 3)}</span>
                  </div>
                  
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2 text-gray-700">
                      <Globe className="w-4 h-4" />
                      <span className="text-sm font-medium">Namespace</span>
                    </div>
                    <span className="text-xs font-mono text-gray-800 break-all">{siteData.namespace.split('-').slice(0, -1).join('.')}</span>
                  </div>
                </div>
              </div>
            </div>

            <div className="bg-white rounded-xl p-6 border border-gray-200 flex flex-col flex-1">
              <h2 className="text-lg font-semibold text-[#36322F] mb-4">Quick Start</h2>
              <div className="space-y-4 flex-1">
                <div>
                  <h3 className="text-sm font-medium text-gray-700 mb-2">1. Test in Dashboard</h3>
                  <p className="text-xs text-gray-600">Use the chat panel to test responses and refine your queries</p>
                </div>
                <div>
                  <h3 className="text-sm font-medium text-gray-700 mb-2">2. Get API Access</h3>
                  <p className="text-xs text-gray-600">Click below to see integration code in multiple languages</p>
                </div>
                <div>
                  <h3 className="text-sm font-medium text-gray-700 mb-2">3. Deploy Anywhere</h3>
                  <p className="text-xs text-gray-600">Deploy chatbot script OR OpenAI-compatible endpoint API</p>
                </div>
              </div>
              <div className="mt-8">
                <Button
                  onClick={() => setShowApiModal(true)}
                  variant="orange"
                  className="w-full"
                >
                  View Integration Code
                </Button>
              </div>
            </div>
          </div>

          {/* Chat Panel and Sources */}
          <div className="lg:w-3/4 h-full">
            <div className="flex gap-6 h-full">
              {/* Chat Panel */}
              <div className="w-2/3 bg-white rounded-xl border border-gray-200 flex flex-col overflow-hidden h-full">
                <div ref={scrollAreaRef} className="flex-1 overflow-y-auto p-6">
                  {messages.length === 0 && (
                    <div className="text-center py-20">
                      <div className="mb-4">
                        {siteData.metadata.favicon && (
                          <Image 
                            src={siteData.metadata.favicon} 
                            alt={siteData.metadata.title}
                            width={64}
                            height={64}
                            className="w-16 h-16 mx-auto mb-4 opacity-50"
                            onError={(e) => {
                              e.currentTarget.style.display = 'none';
                            }}
                          />
                        )}
                      </div>
                      <h3 className="text-lg font-semibold text-[#36322F] mb-2">
                        Chat with {siteData.metadata.title}
                      </h3>
                      <p className="text-gray-600">
                        Ask anything about their {siteData.pagesCrawled} indexed pages
                      </p>
                    </div>
                  )}
                
                  {messages.map((message, index) => (
              <div
                key={index}
                className={`mb-6 ${message.role === 'user' ? 'flex justify-end' : 'flex justify-start'}`}
              >
                <div className={`max-w-[85%] ${message.role === 'user' ? 'ml-12' : 'mr-12'}`}>
                  <div
                    className={`px-5 py-4 rounded-2xl ${
                      message.role === 'user'
                        ? 'bg-orange-500 text-white'
                        : 'bg-white border border-gray-200 text-gray-800 shadow-sm'
                    }`}
                  >
                    {message.role === 'user' ? (
                      <p className="text-[15px] leading-relaxed">{message.content}</p>
                    ) : (
                      <div className="prose prose-sm max-w-none prose-gray">
                        <MarkdownContent 
                          content={message.content} 
                          isStreaming={isLoading && index === messages.length - 1 && message.content !== ''}
                        />
                      </div>
                    )}
                  </div>
                
                  {/* Sources displayed below the message bubble */}
                  {message.role === 'assistant' && message.sources && message.sources.length > 0 && (
                  <div className="mt-4 ml-2">
                    <p className="text-xs font-medium text-gray-600 mb-3">References:</p>
                    <div className="grid grid-cols-1 gap-2 max-w-2xl">
                      {message.sources.map((source, idx) => (
                        <a
                          key={idx}
                          href={source.url}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="flex items-start gap-3 p-3 bg-gray-50 hover:bg-gray-100 rounded-lg border border-gray-200 hover:border-gray-300 transition-all group"
                        >
                          <span className="text-xs font-medium text-gray-500 mt-0.5">[{idx + 1}]</span>
                          <div className="flex-1 min-w-0">
                            <h4 className="text-sm font-medium text-gray-800 group-hover:text-blue-600 transition-colors line-clamp-1">
                              {source.title.length > 60 
                                ? source.title.substring(0, 57) + '...' 
                                : source.title}
                            </h4>
                            {source.snippet && (
                              <p className="text-xs text-gray-600 mt-1 line-clamp-2">
                                {source.snippet.length > 100 
                                  ? source.snippet.substring(0, 97) + '...' 
                                  : source.snippet}
                              </p>
                            )}
                            <p className="text-xs text-gray-500 mt-1 truncate">
                              {source.url}
                            </p>
                          </div>
                          <ExternalLink className="w-4 h-4 text-gray-400 group-hover:text-blue-600 flex-shrink-0 mt-0.5" />
                        </a>
                      ))}
                    </div>
                  </div>
                  )}
                </div>
              </div>
              ))}
              
              {isLoading && messages[messages.length - 1]?.role !== 'assistant' && (
                <div className="flex justify-start mb-6">
                  <div className="max-w-[85%] mr-12">
                    <div className="px-5 py-4 rounded-2xl bg-white border border-gray-200 text-gray-800 shadow-sm">
                      <div className="flex items-center gap-2">
                        <div className="w-2 h-2 bg-orange-500 rounded-full animate-pulse" />
                        <div className="w-2 h-2 bg-orange-500 rounded-full animate-pulse delay-75" />
                        <div className="w-2 h-2 bg-orange-500 rounded-full animate-pulse delay-150" />
                      </div>
                    </div>
                  </div>
                </div>
              )}
                </div>
                
                <form onSubmit={handleSubmit} className="p-4 border-t border-gray-200">
                  <div className="relative">
                    <Input
                      type="text"
                      value={input}
                      onChange={(e) => setInput(e.target.value)}
                      placeholder={`Ask about ${siteData.metadata.title}...`}
                      className="w-full pr-12 placeholder:text-gray-400"
                      disabled={isLoading}
                    />
                    <button
                      type="submit"
                      disabled={isLoading || !input.trim()}
                      className="absolute right-2 top-1/2 -translate-y-1/2 p-2 text-orange-600 hover:text-orange-700 disabled:opacity-50 transition-colors"
                    >
                      <Send className="w-4 h-4" />
                    </button>
                  </div>
                </form>
              </div>
              
              {/* Sources Panel */}
              <div className="w-1/3">
                <div className="bg-white rounded-xl p-6 border border-gray-200 flex flex-col h-full">
                  <div className="flex items-center justify-between mb-4">
                    <h2 className="text-lg font-semibold text-[#36322F]">Knowledge Base</h2>
                  </div>
                  
                  <div className="space-y-3 p-3 flex-1">
                    <div className="text-center py-8">
                      <Database className="w-12 h-12 text-gray-400 mx-auto mb-3" />
                      <p className="text-sm font-medium text-gray-700 mb-1">
                        {siteData.pagesCrawled} pages indexed
                      </p>
                      <p className="text-xs text-gray-500 mb-4">
                        Ready to answer questions about {siteData.metadata.title}
                      </p>
                      <div className="space-y-2 text-left">
                        <div className="flex items-center justify-between p-2 bg-gray-50 rounded">
                          <span className="text-xs text-gray-600">Total chunks</span>
                          <span className="text-xs font-medium text-gray-800">{Math.round(siteData.pagesCrawled * 3)}</span>
                        </div>
                        <div className="flex items-center justify-between p-2 bg-gray-50 rounded">
                          <span className="text-xs text-gray-600">Crawl date</span>
                          <span className="text-xs font-medium text-gray-800">
                            {siteData.crawlDate ? new Date(siteData.crawlDate).toLocaleDateString() : 'N/A'}
                          </span>
                        </div>
                        <div className="flex items-center justify-between p-2 bg-gray-50 rounded">
                          <span className="text-xs text-gray-600">Namespace</span>
                          <span className="text-xs font-mono text-gray-800 truncate max-w-[150px]">
                            {siteData.namespace.split('-').slice(0, -1).join('.')}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      {/* Delete Confirmation Modal */}
      <Dialog open={showDeleteModal} onOpenChange={setShowDeleteModal}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Delete Index</DialogTitle>
            <DialogDescription>
              Are you sure you want to delete the index for {siteData.metadata.title}? This action cannot be undone.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setShowDeleteModal(false)}
            >
              Cancel
            </Button>
            <Button
              variant="destructive"
              onClick={handleDelete}
            >
              Delete
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* API Modal */}
      <Dialog open={showApiModal} onOpenChange={setShowApiModal}>
        <DialogContent className="sm:max-w-4xl bg-white">
          <DialogHeader>
            <DialogTitle>API Access</DialogTitle>
            <DialogDescription>
              Use this index with any OpenAI-compatible API client.
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-3 mb-6">
            <div>
              <span className="text-sm text-gray-600">Model Name:</span>
              <code className="ml-2 text-sm text-orange-600">{modelName}</code>
            </div>
            <div>
              <span className="text-sm text-gray-600">Endpoint:</span>
              <code className="ml-2 text-sm text-gray-700">/api/v1/chat/completions</code>
            </div>
          </div>
          
          {/* Language tabs */}
          <div className="mb-6">
            <div className="flex gap-1 mb-4 border-b border-gray-200">
              <button
                onClick={() => setActiveTab('curl')}
                className={`px-4 py-2 text-sm font-medium transition-colors ${
                  activeTab === 'curl'
                    ? 'text-orange-600 border-b-2 border-orange-600'
                    : 'text-gray-600 hover:text-gray-800'
                }`}
              >
                cURL
              </button>
              <button
                onClick={() => setActiveTab('javascript')}
                className={`px-4 py-2 text-sm font-medium transition-colors ${
                  activeTab === 'javascript'
                    ? 'text-orange-600 border-b-2 border-orange-600'
                    : 'text-gray-600 hover:text-gray-800'
                }`}
              >
                JavaScript
              </button>
              <button
                onClick={() => setActiveTab('python')}
                className={`px-4 py-2 text-sm font-medium transition-colors ${
                  activeTab === 'python'
                    ? 'text-orange-600 border-b-2 border-orange-600'
                    : 'text-gray-600 hover:text-gray-800'
                }`}
              >
                Python
              </button>
            </div>
            
            {/* Tab content */}
            <div className="bg-gray-50 rounded-lg p-4">
              <div className="flex items-center justify-between mb-2">
                <span className="text-sm font-medium text-gray-700">
                  {activeTab === 'curl' && 'cURL Command'}
                  {activeTab === 'javascript' && 'JavaScript Code'}
                  {activeTab === 'python' && 'Python Code'}
                </span>
                <button
                  onClick={() => copyToClipboard(
                    activeTab === 'curl' ? curlCommand : 
                    activeTab === 'javascript' ? jsCode : 
                    pythonCode, 
                    activeTab
                  )}
                  className="text-sm text-orange-600 hover:text-orange-700 flex items-center gap-1"
                >
                  {copiedItem === activeTab ? <Check className="w-4 h-4" /> : <Copy className="w-4 h-4" />}
                  {copiedItem === activeTab ? 'Copied!' : 'Copy'}
                </button>
              </div>
              <pre className="text-sm text-gray-700 overflow-x-auto whitespace-pre-wrap break-all">
                <code>
                  {activeTab === 'curl' && curlCommand}
                  {activeTab === 'javascript' && jsCode}
                  {activeTab === 'python' && pythonCode}
                </code>
              </pre>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  )
}

================
File: app/debug/page.tsx
================
'use client'

import { useState } from 'react'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"

export default function DebugPage() {
  const [namespace, setNamespace] = useState('firecrawl-dev-1749845075753')
  interface DebugResults {
    [key: string]: unknown
  }
  const [results, setResults] = useState<DebugResults | null>(null)
  const [loading, setLoading] = useState(false)

  const runDebug = async () => {
    setLoading(true)
    try {
      const response = await fetch(`/api/firestarter/debug?namespace=${namespace}`)
      const data = await response.json()
      setResults(data)
    } catch (error) {
      console.error('Debug error:', error)
      setResults({ error: error instanceof Error ? error.message : 'Unknown error' })
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="min-h-screen bg-[#FBFAF9] p-8">
      <div className="max-w-4xl mx-auto">
        <h1 className="text-2xl font-bold mb-6">Firestarter Debug</h1>
        
        <div className="bg-white rounded-lg p-6 shadow-sm">
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium mb-2">Namespace</label>
              <Input
                value={namespace}
                onChange={(e) => setNamespace(e.target.value)}
                placeholder="Enter namespace to debug"
              />
            </div>
            
            <Button onClick={runDebug} disabled={loading}>
              {loading ? 'Running...' : 'Run Debug'}
            </Button>
          </div>
          
          {results && (
            <div className="mt-6">
              <h2 className="text-lg font-semibold mb-2">Results:</h2>
              <pre className="bg-gray-100 p-4 rounded overflow-auto text-xs">
                {JSON.stringify(results, null, 2)}
              </pre>
            </div>
          )}
        </div>
        
        <div className="mt-6 bg-white rounded-lg p-6 shadow-sm">
          <h2 className="text-lg font-semibold mb-4">Instructions:</h2>
          <ol className="list-decimal list-inside space-y-2 text-sm">
            <li>First, go to the Indexes page and crawl a website</li>
            <li>Note the namespace that&apos;s returned (it will be shown in the response)</li>
            <li>Enter that namespace above and click &quot;Run Debug&quot;</li>
            <li>This will show you what documents are stored in Upstash</li>
          </ol>
        </div>
      </div>
    </div>
  )
}

================
File: app/indexes/page.tsx
================
'use client'

import { useRouter } from 'next/navigation'
import Image from "next/image"
import Link from "next/link"
import { Button } from "@/components/ui/button"
import { Globe, FileText, Database, ExternalLink, Trash2, Calendar } from 'lucide-react'
import { toast } from "sonner"
import { useStorage } from "@/hooks/useStorage"

interface IndexedSite {
  url: string
  namespace: string
  pagesCrawled: number
  createdAt: string
  metadata?: {
    title?: string
    description?: string
    favicon?: string
    ogImage?: string
  }
}

function formatDate(dateString: string) {
  const date = new Date(dateString)
  const now = new Date()
  const diffInMs = now.getTime() - date.getTime()
  const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24))
  
  if (diffInDays === 0) {
    return 'Today'
  } else if (diffInDays === 1) {
    return 'Yesterday'
  } else if (diffInDays < 7) {
    return `${diffInDays} days ago`
  } else {
    return date.toLocaleDateString()
  }
}

export default function IndexesPage() {
  const router = useRouter()
  const { indexes, loading, deleteIndex, isUsingRedis } = useStorage()

  const handleSelectIndex = (index: IndexedSite) => {
    // Store the site info in session storage for the dashboard
    const siteInfo = {
      url: index.url,
      namespace: index.namespace,
      pagesCrawled: index.pagesCrawled,
      crawlDate: index.createdAt,
      metadata: index.metadata || {},
      crawlComplete: true,
      fromIndex: true // Flag to indicate this is from the index list
    }
    
    sessionStorage.setItem('firestarter_current_data', JSON.stringify(siteInfo))
    
    // Navigate to the dashboard with namespace parameter
    router.push(`/dashboard?namespace=${index.namespace}`)
  }

  const handleDeleteIndex = async (index: IndexedSite, e: React.MouseEvent) => {
    e.stopPropagation()
    
    if (confirm(`Delete chatbot for ${index.metadata?.title || index.url}?`)) {
      try {
        await deleteIndex(index.namespace)
        toast.success('Chatbot deleted successfully')
      } catch (e) {
        console.error('Error deleting index:', e)
        toast.error('Failed to delete chatbot')
      }
    }
  }

  const formatDate = (dateString: string) => {
    const date = new Date(dateString)
    return date.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric', 
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    })
  }

  return (
    <div className="px-4 sm:px-6 lg:px-8 py-4 max-w-7xl mx-auto font-inter">
      <div className="flex justify-between items-center mb-8">
        <Link href="https://www.firecrawl.dev/?utm_source=tool-firestarter" target="_blank" rel="noopener noreferrer">
          <Image
            src="/firecrawl-logo-with-fire.png"
            alt="Firecrawl Logo"
            width={113}
            height={24}
          />
        </Link>
        <Button
          asChild
          variant="orange"
          size="sm"
        >
          <Link href="/">
            Create New Chatbot
          </Link>
        </Button>
      </div>

      <div className="mb-8">
        <h1 className="text-3xl font-semibold text-[#36322F] mb-2">Your Chatbots</h1>
        <p className="text-gray-600">
          View and manage all your chatbots
          {isUsingRedis && <span className="text-xs text-gray-500 ml-2">(using Redis storage)</span>}
        </p>
      </div>

      {loading ? (
        <div className="text-center py-10">
          <p className="text-gray-600">Loading indexes...</p>
        </div>
      ) : indexes.length === 0 ? (
        <div className="text-center py-20">
          <Globe className="w-16 h-16 text-gray-300 mx-auto mb-4" />
          <h3 className="text-xl font-semibold text-gray-700 mb-2">No Chatbots Yet</h3>
          <p className="text-gray-600 mb-6">You haven&apos;t created any chatbots yet.</p>
          <Button asChild variant="orange">
            <Link href="/firestarter">
              Create Your First Chatbot
            </Link>
          </Button>
        </div>
      ) : (
        <div className="grid grid-cols-1 gap-4">
          {indexes.map((index) => (
            <div
              key={index.namespace}
              onClick={() => handleSelectIndex(index)}
              className="bg-white rounded-xl border border-gray-200 hover:shadow-md transition-shadow cursor-pointer group overflow-hidden"
            >
              <div className="flex items-stretch">
                {/* Left side - OG Image */}
                <div className="relative w-64 flex-shrink-0">
                  {index.metadata?.ogImage ? (
                    <>
                      <Image 
                        src={index.metadata.ogImage} 
                        alt={index.metadata?.title || 'Site image'}
                        fill
                        className="object-cover bg-gray-50"
                        onError={(e) => {
                          e.currentTarget.style.display = 'none';
                          e.currentTarget.parentElement?.querySelector('.fallback-icon')?.classList.remove('hidden');
                        }}
                      />
                      <div className="absolute inset-0 bg-gradient-to-r from-transparent to-white/50"></div>
                      <div className="fallback-icon hidden w-full h-full bg-gray-100 flex items-center justify-center absolute inset-0">
                        <Globe className="w-12 h-12 text-gray-400" />
                      </div>
                    </>
                  ) : (
                    <div className="w-full h-full bg-gray-100 flex items-center justify-center">
                      <Globe className="w-12 h-12 text-gray-400" />
                    </div>
                  )}
                  {index.metadata?.favicon && (
                    <div className="absolute bottom-2 left-2 w-8 h-8 bg-white rounded-lg p-1 shadow-sm">
                      <Image 
                        src={index.metadata.favicon} 
                        alt="favicon"
                        width={24}
                        height={24}
                        className="w-full h-full object-contain"
                        onError={(e) => {
                          e.currentTarget.parentElement!.style.display = 'none';
                        }}
                      />
                    </div>
                  )}
                </div>
                
                {/* Right side - Content */}
                <div className="flex items-start justify-between p-6 flex-1">
                  <div className="flex-1 min-w-0">
                    <h3 className="text-lg font-semibold text-[#36322F] group-hover:text-orange-600 transition-colors">
                      {index.metadata?.title || new URL(index.url).hostname}
                    </h3>
                    <p className="text-sm text-gray-600 mt-1">{index.url}</p>
                    {index.metadata?.description && (
                      <p className="text-sm text-gray-500 mt-2 line-clamp-2">
                        {index.metadata.description}
                      </p>
                    )}
                    
                    <div className="flex items-center gap-6 mt-4 text-sm text-gray-600">
                      <div className="flex items-center gap-2">
                        <FileText className="w-4 h-4" />
                        <span>{index.pagesCrawled} pages</span>
                      </div>
                      <div className="flex items-center gap-2">
                        <Database className="w-4 h-4" />
                        <span className="font-mono text-xs">{index.namespace.split('-').slice(0, -1).join('.')}</span>
                      </div>
                      <div className="flex items-center gap-2">
                        <Calendar className="w-4 h-4" />
                        <span>{formatDate(index.createdAt)}</span>
                      </div>
                    </div>
                  </div>
                  
                  <div className="flex items-center gap-2">
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={(e) => handleDeleteIndex(index, e)}
                      className="opacity-0 group-hover:opacity-100 transition-opacity text-red-600 hover:text-red-700 hover:bg-red-50"
                    >
                      <Trash2 className="w-4 h-4" />
                    </Button>
                    <ExternalLink className="w-5 h-5 text-gray-400 group-hover:text-gray-600 transition-colors" />
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}

================
File: app/globals.css
================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

/* Glowing border animation for email column */
@keyframes glow-pulse {
  0%, 100% {
    box-shadow: 
      0 0 20px rgba(251, 146, 60, 0.5),
      0 0 40px rgba(251, 146, 60, 0.3),
      0 0 60px rgba(251, 146, 60, 0.1);
  }
  50% {
    box-shadow: 
      0 0 30px rgba(251, 146, 60, 0.8),
      0 0 60px rgba(251, 146, 60, 0.5),
      0 0 90px rgba(251, 146, 60, 0.3);
  }
}

.email-column-glow {
  animation: glow-pulse 2s ease-in-out infinite;
  position: relative;
}

/* Rounded corners for email column */
.email-column-rounded-top {
  border-top-left-radius: 0.5rem;
  border-top-right-radius: 0.5rem;
}

.email-column-rounded-bottom {
  border-bottom-left-radius: 0.5rem;
  border-bottom-right-radius: 0.5rem;
}

.email-column-glow::before {
  content: '';
  position: absolute;
  inset: -2px;
  border-radius: 0.5rem;
  padding: 2px;
  background: linear-gradient(45deg, rgba(251, 146, 60, 0.8), rgba(251, 191, 36, 0.8));
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  opacity: 0.7;
  animation: glow-pulse 2s ease-in-out infinite;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222 47% 11%;
    --card: 0 0% 100%;
    --card-foreground: 222 47% 11%;
    --popover: 0 0% 100%;
    --popover-foreground: 222 47% 11%;
    --primary: 350 100% 62%;
    --primary-foreground: 0 0% 100%;
    --secondary: 240 5% 96%;
    --secondary-foreground: 222 47% 11%;
    --muted: 240 5% 96%;
    --muted-foreground: 240 4% 46%;
    --accent: 240 5% 96%;
    --accent-foreground: 222 47% 11%;
    --destructive: 0 85% 60%;
    --destructive-foreground: 0 0% 100%;
    --border: 240 6% 90%;
    --input: 240 6% 90%;
    --ring: 350 100% 62%;
    --radius: 0.75rem;
    
    /* New gradient variables */
    --gradient-primary: linear-gradient(135deg, #FF6B6B 0%, #FF5E5E 25%, #FF8E53 100%);
    --gradient-secondary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    --gradient-accent: linear-gradient(135deg, #FA8BFF 0%, #2BD2FF 52%, #2BFF88 90%);
    --gradient-subtle: linear-gradient(135deg, #FFECD2 0%, #FCB69F 100%);
    --gradient-dark: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    
    /* Shadow variables */
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
    --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
    --shadow-glow: 0 0 20px rgb(255 107 107 / 0.3);
    
    /* Animation durations and delays */
    --d-1: 150ms;
    --d-2: 300ms;
    --d-3: 500ms;
    --t-1: 200ms;
    --t-2: 400ms;
    --t-3: 600ms;
    --spring: cubic-bezier(0.175, 0.885, 0.32, 1.275);
    --ease: cubic-bezier(0.4, 0, 0.2, 1);
  }

  .dark {
    --background: 222 47% 7%;
    --foreground: 0 0% 98%;
    --card: 222 47% 9%;
    --card-foreground: 0 0% 98%;
    --popover: 222 47% 9%;
    --popover-foreground: 0 0% 98%;
    --primary: 350 100% 62%;
    --primary-foreground: 0 0% 100%;
    --secondary: 222 47% 15%;
    --secondary-foreground: 0 0% 98%;
    --muted: 222 47% 15%;
    --muted-foreground: 215 20% 65%;
    --accent: 222 47% 15%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 85% 60%;
    --destructive-foreground: 0 0% 100%;
    --border: 222 47% 20%;
    --input: 222 47% 20%;
    --ring: 350 100% 62%;
    
    /* Dark mode gradient adjustments */
    --gradient-primary: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%);
    --gradient-secondary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    --gradient-accent: linear-gradient(135deg, #FA8BFF 0%, #2BD2FF 52%, #2BFF88 90%);
    --gradient-subtle: linear-gradient(135deg, rgba(255, 107, 107, 0.1) 0%, rgba(255, 142, 83, 0.1) 100%);
    --gradient-dark: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 100%);
    
    /* Dark mode shadows */
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.5);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.5), 0 2px 4px -2px rgb(0 0 0 / 0.5);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.5), 0 4px 6px -4px rgb(0 0 0 / 0.5);
    --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.5), 0 8px 10px -6px rgb(0 0 0 / 0.5);
    --shadow-glow: 0 0 30px rgb(255 107 107 / 0.5);
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
}

:root {
  --sidebar: hsl(0 0% 98%);
  --sidebar-foreground: hsl(240 5.3% 26.1%);
  --sidebar-primary: hsl(240 5.9% 10%);
  --sidebar-primary-foreground: hsl(0 0% 98%);
  --sidebar-accent: hsl(240 4.8% 95.9%);
  --sidebar-accent-foreground: hsl(240 5.9% 10%);
  --sidebar-border: hsl(220 13% 91%);
  --sidebar-ring: hsl(217.2 91.2% 59.8%);
}

.dark {
  --sidebar: hsl(240 5.9% 10%);
  --sidebar-foreground: hsl(240 4.8% 95.9%);
  --sidebar-primary: hsl(224.3 76.3% 48%);
  --sidebar-primary-foreground: hsl(0 0% 100%);
  --sidebar-accent: hsl(240 3.7% 15.9%);
  --sidebar-accent-foreground: hsl(240 4.8% 95.9%);
  --sidebar-border: hsl(240 3.7% 15.9%);
  --sidebar-ring: hsl(217.2 91.2% 59.8%);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@keyframes text {
  to {
    background-position: 200% center;
  }
}

.animate-text {
  animation: text 5s ease infinite;
  background-size: 200% auto;
}

@keyframes fade-up {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-fade-up {
  animation-name: fade-up;
  animation-fill-mode: forwards;
}

@keyframes fade-in {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes scale-in {
  from {
    transform: scale(0);
  }
  to {
    transform: scale(1);
  }
}

.animate-fade-in {
  animation: fade-in 0.3s ease-out forwards;
}

.animate-scale-in {
  animation: scale-in 0.2s ease-out;
}

@keyframes shimmer {
  0% {
    background-position: -1000px 0;
  }
  100% {
    background-position: 1000px 0;
  }
}

.animate-shimmer {
  background: linear-gradient(
    90deg,
    transparent 0%,
    rgba(255, 255, 255, 0.4) 50%,
    transparent 100%
  );
  background-size: 1000px 100%;
  animation: shimmer 2s infinite;
}

/* New animations */
@keyframes float {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-20px); }
}

@keyframes pulse-glow {
  0%, 100% { 
    box-shadow: 0 0 20px rgb(255 107 107 / 0.5),
                0 0 40px rgb(255 107 107 / 0.3);
  }
  50% { 
    box-shadow: 0 0 30px rgb(255 107 107 / 0.8),
                0 0 60px rgb(255 107 107 / 0.4);
  }
}

@keyframes gradient-shift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

@keyframes slide-up-fade {
  0% {
    opacity: 0;
    transform: translateY(40px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Utility classes */
.glass {
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.dark .glass {
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.gradient-border {
  position: relative;
  background: linear-gradient(var(--background), var(--background)) padding-box,
              var(--gradient-primary) border-box;
  border: 2px solid transparent;
}

.gradient-text {
  background: var(--gradient-primary);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.hover-lift {
  transition: all 0.3s var(--spring);
}

.hover-lift:hover {
  transform: translateY(-4px);
  box-shadow: var(--shadow-xl);
}

.animate-gradient {
  background-size: 200% 200%;
  animation: gradient-shift 3s ease infinite;
}

.animate-float {
  animation: float 6s ease-in-out infinite;
}

.animate-pulse-glow {
  animation: pulse-glow 2s ease-in-out infinite;
}

/* Premium button styles */
.btn-gradient {
  background: var(--gradient-primary);
  color: white;
  font-weight: 600;
  position: relative;
  overflow: hidden;
  transition: all 0.3s var(--ease);
}

.btn-gradient:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 20px rgb(255 107 107 / 0.3);
}

.btn-gradient::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
  transition: left 0.5s;
}

.btn-gradient:hover::before {
  left: 100%;
}

/* Card hover effects */
.card-hover {
  transition: all 0.3s var(--spring);
  cursor: pointer;
}

.card-hover:hover {
  transform: translateY(-8px) scale(1.02);
  box-shadow: var(--shadow-xl);
}

/* Smooth number transitions */
.number-transition {
  transition: all 0.8s var(--spring);
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--muted);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: var(--muted-foreground);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--foreground);
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { cn } from "@/lib/utils";
import { Analytics } from "@vercel/analytics/next";

const inter = Inter({
  variable: "--font-inter",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Firecrawl Tools - AI-Powered Web Scraping & Data Enrichment",
  description: "Transform websites into structured data with Firecrawl's suite of AI tools. Create chatbots, enrich CSVs, search intelligently, and generate images from URLs.",
  metadataBase: new URL(process.env.NEXT_PUBLIC_URL || "https://firecrawl.dev"),
  openGraph: {
    title: "Firecrawl Tools - AI-Powered Web Scraping & Data Enrichment",
    description: "Transform websites into structured data with Firecrawl's suite of AI tools. Create chatbots, enrich CSVs, search intelligently, and generate images from URLs.",
    url: "/",
    siteName: "Firecrawl Tools",
    images: [
      {
        url: "/firecrawl-logo-with-fire.png",
        width: 1200,
        height: 630,
        alt: "Firecrawl - AI-Powered Web Scraping",
      },
    ],
    locale: "en_US",
    type: "website",
  },
  twitter: {
    card: "summary_large_image",
    title: "Firecrawl Tools - AI-Powered Web Scraping",
    description: "Transform websites into structured data with AI",
    images: ["/firecrawl-logo-with-fire.png"],
    creator: "@firecrawl_dev",
  },
  icons: {
    icon: "/favicon.ico",
    shortcut: "/favicon.ico",
    apple: "/favicon.ico",
  },
  robots: {
    index: true,
    follow: true,
    googleBot: {
      index: true,
      follow: true,
      "max-video-preview": -1,
      "max-image-preview": "large",
      "max-snippet": -1,
    },
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        suppressHydrationWarning={true}
        className={cn(
          "min-h-screen bg-background font-sans antialiased",
          inter.variable
        )}
      >
        <main className="">
          {children}
        </main>
        <Analytics />
      </body>
    </html>
  );
}

================
File: app/page.tsx
================
"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import Image from "next/image";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useStorage } from "@/hooks/useStorage";
import { 
  Globe, 
  ArrowRight, 
  Settings, 
  Loader2, 
  CheckCircle2, 
  FileText, 
  AlertCircle,
  Database,
  Zap,
  Search,
  Sparkles,
  Lock,
  ExternalLink
} from "lucide-react";
import { toast } from "sonner";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";

export default function FirestarterPage() {
  const router = useRouter();
  const searchParams = new URLSearchParams(typeof window !== 'undefined' ? window.location.search : '');
  const urlParam = searchParams.get('url');
  const { saveIndex } = useStorage();
  
  const [url, setUrl] = useState(urlParam || 'https://firecrawl.dev');
  const [hasInteracted, setHasInteracted] = useState(false);
  const [loading, setLoading] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [pageLimit, setPageLimit] = useState(10);
  const [isCreationDisabled, setIsCreationDisabled] = useState<boolean | undefined>(undefined);
  const [crawlProgress, setCrawlProgress] = useState<{
    status: string;
    pagesFound: number;
    pagesScraped: number;
    currentPage?: string;
  } | null>(null);
  const [showApiKeyModal, setShowApiKeyModal] = useState(false);
  const [firecrawlApiKey, setFirecrawlApiKey] = useState<string>('');
  const [isValidatingApiKey, setIsValidatingApiKey] = useState(false);
  const [hasFirecrawlKey, setHasFirecrawlKey] = useState(false);

  useEffect(() => {
    // Check environment and API keys
    fetch('/api/check-env')
      .then(res => res.json())
      .then(data => {
        setIsCreationDisabled(data.environmentStatus.FIRESTARTER_DISABLE_CREATION_DASHBOARD || false);
        
        // Check for Firecrawl API key
        const hasEnvFirecrawl = data.environmentStatus.FIRECRAWL_API_KEY;
        setHasFirecrawlKey(hasEnvFirecrawl);
        
        if (!hasEnvFirecrawl) {
          // Check localStorage for saved API key
          const savedKey = localStorage.getItem('firecrawl_api_key');
          if (savedKey) {
            setFirecrawlApiKey(savedKey);
            setHasFirecrawlKey(true);
          }
        }
      })
      .catch(() => {
        setIsCreationDisabled(false);
      });
  }, []);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!url) return;

    // Check if we have Firecrawl API key
    
    if (!hasFirecrawlKey && !localStorage.getItem('firecrawl_api_key')) {
      setShowApiKeyModal(true);
      return;
    }

    // Normalize URL
    let normalizedUrl = url.trim();
    if (!normalizedUrl.startsWith('http://') && !normalizedUrl.startsWith('https://')) {
      normalizedUrl = 'https://' + normalizedUrl;
    }
    
    // Validate URL
    try {
      new URL(normalizedUrl);
    } catch {
      toast.error('Please enter a valid URL');
      return;
    }

    setLoading(true);
    setCrawlProgress({
      status: 'Starting crawl...',
      pagesFound: 0,
      pagesScraped: 0
    });
    
    interface CrawlResponse {
      success: boolean
      namespace: string
      crawlId?: string
      details: {
        url: string
        pagesCrawled: number
      }
      data: Array<{
        url?: string
        metadata?: {
          sourceURL?: string
          title?: string
          ogTitle?: string
          description?: string
          ogDescription?: string
          favicon?: string
          ogImage?: string
          'og:image'?: string
          'twitter:image'?: string
        }
      }>
    }
    
    let data: CrawlResponse | null = null;
    
    try {
      // Simulate progressive updates
      let currentProgress = 0;
      
      const progressInterval = setInterval(() => {
        currentProgress += Math.random() * 3;
        if (currentProgress > pageLimit * 0.8) {
          clearInterval(progressInterval);
        }
        
        setCrawlProgress(prev => {
          if (!prev) return null;
          const scraped = Math.min(Math.floor(currentProgress), pageLimit);
          return {
            ...prev,
            status: scraped < pageLimit * 0.3 ? 'Discovering pages...' : 
                   scraped < pageLimit * 0.7 ? 'Scraping content...' : 
                   'Finalizing...',
            pagesFound: pageLimit,
            pagesScraped: scraped,
            currentPage: scraped > 0 ? `Processing page ${scraped} of ${pageLimit}` : undefined
          };
        });
      }, 300);
      
      // Get API key from localStorage if not in environment
      const firecrawlApiKey = localStorage.getItem('firecrawl_api_key');
      
      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
      };
      
      // Add API key to headers if available from localStorage (and not in env)
      if (firecrawlApiKey) {
        headers['X-Firecrawl-API-Key'] = firecrawlApiKey;
      }
      
      const response = await fetch('/api/firestarter/create', {
        method: 'POST',
        headers,
        body: JSON.stringify({ url: normalizedUrl, limit: pageLimit })
      });

      data = await response.json();
      
      // Clear the interval
      if (progressInterval) clearInterval(progressInterval);
      
      if (data && data.success) {
        // Update progress to show completion
        setCrawlProgress({
          status: 'Crawl complete!',
          pagesFound: data.details?.pagesCrawled || 0,
          pagesScraped: data.details?.pagesCrawled || 0
        });
        
        // Find the homepage in crawled data for metadata
        let homepageMetadata: {
          title?: string
          ogTitle?: string
          description?: string
          ogDescription?: string
          favicon?: string
          ogImage?: string
          'og:image'?: string
          'twitter:image'?: string
        } = {};
        if (data.data && data.data.length > 0) {
          const homepage = data.data.find((page) => {
            const pageUrl = page.metadata?.sourceURL || page.url || '';
            // Check if it's the homepage
            return pageUrl === normalizedUrl || pageUrl === normalizedUrl + '/' || pageUrl === normalizedUrl.replace(/\/$/, '');
          }) || data.data[0]; // Fallback to first page
          
          homepageMetadata = homepage.metadata || {};
        }
        
        // Store the crawl info and redirect to dashboard
        const siteInfo = {
          url: normalizedUrl,
          namespace: data.namespace,
          crawlId: data.crawlId,
          pagesCrawled: data.details?.pagesCrawled || 0,
          crawlComplete: true,
          crawlDate: new Date().toISOString(),
          metadata: {
            title: homepageMetadata.ogTitle || homepageMetadata.title || new URL(normalizedUrl).hostname,
            description: homepageMetadata.ogDescription || homepageMetadata.description || 'Your custom website',
            favicon: homepageMetadata.favicon,
            ogImage: homepageMetadata.ogImage || homepageMetadata['og:image'] || homepageMetadata['twitter:image']
          }
        };
        
        // Store only metadata for current session (no crawlData - that's in Upstash)
        sessionStorage.setItem('firestarter_current_data', JSON.stringify(siteInfo));
        
        // Save index metadata using the storage hook
        await saveIndex({
          url: normalizedUrl,
          namespace: data.namespace,
          pagesCrawled: data.details?.pagesCrawled || 0,
          createdAt: new Date().toISOString(),
          metadata: {
            title: homepageMetadata.ogTitle || homepageMetadata.title || new URL(normalizedUrl).hostname,
            description: homepageMetadata.ogDescription || homepageMetadata.description || 'Your custom website',
            favicon: homepageMetadata.favicon,
            ogImage: homepageMetadata.ogImage || homepageMetadata['og:image'] || homepageMetadata['twitter:image']
          }
        });
        
        // Small delay to show completion
        setTimeout(() => {
          router.push(`/dashboard?namespace=${siteInfo.namespace}`);
        }, 1000);
      } else if (data && 'error' in data) {
        setCrawlProgress({
          status: 'Error: ' + (data as { error: string }).error,
          pagesFound: 0,
          pagesScraped: 0
        });
        toast.error((data as { error: string }).error);
      }
    } catch {
      toast.error('Failed to start crawling. Please try again.');
    } finally {
      if (!data?.success) {
        setLoading(false);
        setCrawlProgress(null);
      }
    }
  };

  const handleApiKeySubmit = async () => {
    if (!firecrawlApiKey.trim()) {
      toast.error('Please enter a valid Firecrawl API key');
      return;
    }

    setIsValidatingApiKey(true);

    try {
      // Test the Firecrawl API key
      const response = await fetch('/api/scrape', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Firecrawl-API-Key': firecrawlApiKey,
        },
        body: JSON.stringify({ url: 'https://example.com' }),
      });

      if (!response.ok) {
        throw new Error('Invalid Firecrawl API key');
      }
      
      // Save the API key to localStorage
      localStorage.setItem('firecrawl_api_key', firecrawlApiKey);
      setHasFirecrawlKey(true);

      toast.success('API key saved successfully!');
      setShowApiKeyModal(false);

      // Trigger form submission after API key is saved
      if (url) {
        const form = document.querySelector('form');
        if (form) {
          form.requestSubmit();
        }
      }
    } catch {
      toast.error('Invalid API key. Please check and try again.');
    } finally {
      setIsValidatingApiKey(false);
    }
  };

  return (
    <div className="px-4 sm:px-6 lg:px-8 py-4 max-w-7xl mx-auto font-inter">
      <div className="flex justify-between items-center mb-8">
        <Link href="https://www.firecrawl.dev/?utm_source=tool-firestarter" target="_blank" rel="noopener noreferrer">
          <Image
            src="/firecrawl-logo-with-fire.png"
            alt="Firecrawl Logo"
            width={113}
            height={24}
          />
        </Link>
        <div className="flex items-center gap-2">
          <Button
            asChild
            variant="orange"
            className="font-medium"
          >
            <Link href="/indexes">
              View All
            </Link>
          </Button>
          <Button
            asChild
            variant="code"
            className="font-medium flex items-center gap-2"
          >
            <a
              href="https://github.com/mendableai/hostedTools/tree/main/app/firestarter"
              target="_blank"
              rel="noopener noreferrer"
            >
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" className="w-4 h-4">
                <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
              </svg>
              Use this template
            </a>
          </Button>
        </div>
      </div>

      {isCreationDisabled === undefined ? (
        // Show loading state while checking environment
        <div className="max-w-2xl mx-auto">
          <div className="text-center pt-8 pb-6">
            <h1 className="text-[2.5rem] lg:text-[3.8rem] text-center text-[#36322F] dark:text-zinc-100 font-semibold tracking-tight leading-[1.1] opacity-0 animate-fade-up [animation-duration:500ms] [animation-delay:200ms] [animation-fill-mode:forwards]">
              Firestarter<br />
              <span className="text-[2.5rem] lg:text-[3.8rem] block mt-2 opacity-0 animate-fade-up [animation-duration:500ms] [animation-delay:400ms] [animation-fill-mode:forwards] text-transparent bg-clip-text bg-gradient-to-tr from-red-600 to-yellow-500">
                Loading...
              </span>
            </h1>
          </div>
        </div>
      ) : isCreationDisabled === true ? (
        <div className="max-w-2xl mx-auto">
          <div className="text-center pt-8 pb-6">
            <h1 className="text-[2.5rem] lg:text-[3.8rem] text-center text-[#36322F] dark:text-zinc-100 font-semibold tracking-tight leading-[1.1] opacity-0 animate-fade-up [animation-duration:500ms] [animation-delay:200ms] [animation-fill-mode:forwards]">
              Firestarter<br />
              <span className="text-[2.5rem] lg:text-[3.8rem] block mt-2 opacity-0 animate-fade-up [animation-duration:500ms] [animation-delay:400ms] [animation-fill-mode:forwards] text-transparent bg-clip-text bg-gradient-to-tr from-gray-400 to-gray-600">
                Read-Only Mode
              </span>
            </h1>
          </div>
          
          <div className="bg-orange-50 border border-orange-200 rounded-xl p-8 text-center">
            <Lock className="h-12 w-12 text-orange-600 mx-auto mb-4" />
            <h2 className="text-xl font-semibold text-[#36322F] mb-2">
              Dashboard Creation Disabled
            </h2>
            <p className="text-gray-600 mb-6">
              The dashboard for creation of chatbots has been disabled - only read-only access is available right now.
            </p>
            <div className="flex gap-4 justify-center">
              <Button
                asChild
                variant="orange"
                className="font-medium"
              >
                <Link href="/indexes">
                  View Existing Chatbots
                </Link>
              </Button>
              <Button
                asChild
                variant="outline"
                className="font-medium"
              >
                <Link href="/">
                  Back to Home
                </Link>
              </Button>
            </div>
          </div>
        </div>
      ) : (
        <>
          <div className="text-center pt-8 pb-6">
            <h1 className="text-[2.5rem] lg:text-[3.8rem] text-center text-[#36322F] dark:text-zinc-100 font-semibold tracking-tight leading-[1.1] opacity-0 animate-fade-up [animation-duration:500ms] [animation-delay:200ms] [animation-fill-mode:forwards]">
              Firestarter<br />
              <span className="text-[2.5rem] lg:text-[3.8rem] block mt-2 opacity-0 animate-fade-up [animation-duration:500ms] [animation-delay:400ms] [animation-fill-mode:forwards] text-transparent bg-clip-text bg-gradient-to-tr from-red-600 to-yellow-500">
                Chatbots, Instantly.
              </span>
            </h1>
          </div>

          <div className="max-w-2xl mx-auto">
            <form onSubmit={handleSubmit} className="space-y-4">
              <div className="relative">
                <Input
                  type="text"
                  value={url}
                  onChange={(e) => {
                    setUrl(e.target.value);
                    setHasInteracted(true);
                  }}
                  onFocus={() => {
                    if (!hasInteracted && url === 'https://firecrawl.dev') {
                      setUrl('');
                      setHasInteracted(true);
                    }
                  }}
                  placeholder="https://example.com"
                  className="w-full h-14 px-6 text-lg"
                  required
                  disabled={loading}
                />
                <Button
                  type="submit"
                  disabled={loading}
                  variant="orange"
                  className="absolute right-2 top-2 h-10"
                >
                  {loading ? (
                    <>
                      <Loader2 className="w-4 h-4 animate-spin mr-2" />
                      Crawling...
                    </>
                  ) : (
                    <>
                      Start
                      <ArrowRight className="w-4 h-4 ml-2" />
                    </>
                  )}
                </Button>
              </div>
            </form>

            {/* Loading Progress */}
            {loading && crawlProgress && (
              <div className="mt-8 p-6 bg-[#FBFAF9] rounded-xl border border-gray-200 animate-in fade-in slide-in-from-bottom-4 duration-500">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-lg font-semibold text-[#36322F] flex items-center gap-2">
                    {crawlProgress.status === 'Crawl complete!' ? (
                      <CheckCircle2 className="w-5 h-5 text-green-600 animate-in zoom-in duration-300" />
                    ) : crawlProgress.status.includes('Error') ? (
                      <AlertCircle className="w-5 h-5 text-red-600 animate-in zoom-in duration-300" />
                    ) : (
                      <Loader2 className="w-5 h-5 text-orange-600 animate-spin" />
                    )}
                    <span className="animate-in fade-in duration-300">{crawlProgress.status}</span>
                  </h3>
                </div>
                
                <div className="space-y-3">
                  <div className="flex items-center justify-between text-sm">
                    <span className="text-gray-600">Pages discovered</span>
                    <span className="text-[#36322F] font-medium transition-all duration-300">
                      {crawlProgress.pagesFound}
                    </span>
                  </div>
                  
                  <div className="flex items-center justify-between text-sm">
                    <span className="text-gray-600">Pages scraped</span>
                    <span className="text-[#36322F] font-medium transition-all duration-300">
                      {crawlProgress.pagesScraped}
                    </span>
                  </div>
                  
                  {crawlProgress.pagesFound > 0 && (
                    <div className="mt-4">
                      <div className="w-full bg-gray-200 rounded-full h-2">
                        <div 
                          className="bg-gradient-to-r from-orange-500 to-red-600 h-2 rounded-full transition-all duration-500"
                          style={{ width: `${(crawlProgress.pagesScraped / crawlProgress.pagesFound) * 100}%` }}
                        />
                      </div>
                    </div>
                  )}
                  
                  {crawlProgress.currentPage && (
                    <div className="mt-4 p-3 bg-gray-50 rounded-lg">
                      <p className="text-xs text-gray-600 mb-1">Currently scraping:</p>
                      <p className="text-sm text-gray-800 truncate flex items-center gap-2">
                        <FileText className="w-4 h-4 text-gray-500" />
                        {crawlProgress.currentPage}
                      </p>
                    </div>
                  )}
                </div>
              </div>
            )}

            {/* Settings Button */}
            <div className="mt-6 flex justify-center">
              <Button
                type="button"
                onClick={() => setShowSettings(!showSettings)}
                variant="code"
                size="sm"
                className="font-medium"
              >
                <Settings className="w-4 h-4 mr-2" />
                Advanced Settings
              </Button>
            </div>

            {/* Settings Panel */}
            {showSettings && (
              <div className="mt-4 p-6 bg-[#FBFAF9] rounded-xl border border-gray-200">
                <h3 className="text-lg font-semibold text-[#36322F] mb-4">Crawl Settings</h3>
                
                <div className="space-y-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Maximum pages to crawl
                    </label>
                    <div className="flex items-center gap-4">
                      <input
                        type="range"
                        min="10"
                        max="100"
                        step="10"
                        value={pageLimit}
                        onChange={(e) => setPageLimit(parseInt(e.target.value))}
                        className="flex-1 accent-orange-500"
                        disabled={loading}
                      />
                      <span className="text-[#36322F] font-medium w-12 text-right">{pageLimit}</span>
                    </div>
                    <p className="mt-2 text-xs text-gray-600">
                      More pages = better coverage but longer crawl time
                    </p>
                    <p className="mt-1 text-xs text-gray-500">
                      * To set limit higher - feel free to pull the GitHub repo and deploy your own version (with a better copy)
                    </p>
                  </div>
                  
                  <div className="grid grid-cols-4 gap-2 mt-4">
                    {[10, 25, 50, 100].map(limit => (
                      <Button
                        key={limit}
                        type="button"
                        onClick={() => setPageLimit(limit)}
                        disabled={loading}
                        variant={pageLimit === limit ? "orange" : "outline"}
                        size="sm"
                      >
                        {limit}
                      </Button>
                    ))}
                  </div>
                </div>
              </div>
            )}

            <div className="mt-12">
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div className="bg-[#FBFAF9] rounded-xl border border-gray-200 px-6 py-4 flex items-center gap-3 hover:shadow-sm transition-shadow">
                  <div className="w-8 h-8 bg-orange-100 rounded-lg flex items-center justify-center flex-shrink-0">
                    <Globe className="w-4 h-4 text-orange-600" />
                  </div>
                  <div className="flex items-center">
                    <h3 className="text-base font-semibold text-[#36322F]">Smart Crawling</h3>
                  </div>
                </div>
                
                <div className="bg-[#FBFAF9] rounded-xl border border-gray-200 px-6 py-4 flex items-center gap-3 hover:shadow-sm transition-shadow">
                  <div className="w-8 h-8 bg-orange-100 rounded-lg flex items-center justify-center flex-shrink-0">
                    <FileText className="w-4 h-4 text-orange-600" />
                  </div>
                  <div className="flex items-center">
                    <h3 className="text-base font-semibold text-[#36322F]">Content Extraction</h3>
                  </div>
                </div>
                
                <div className="bg-[#FBFAF9] rounded-xl border border-gray-200 px-6 py-4 flex items-center gap-3 hover:shadow-sm transition-shadow">
                  <div className="w-8 h-8 bg-orange-100 rounded-lg flex items-center justify-center flex-shrink-0">
                    <Database className="w-4 h-4 text-orange-600" />
                  </div>
                  <div className="flex items-center">
                    <h3 className="text-base font-semibold text-[#36322F]">Intelligent Chunking</h3>
                  </div>
                </div>
                
                <div className="bg-[#FBFAF9] rounded-xl border border-gray-200 px-6 py-4 flex items-center gap-3 hover:shadow-sm transition-shadow">
                  <div className="w-8 h-8 bg-orange-100 rounded-lg flex items-center justify-center flex-shrink-0">
                    <Search className="w-4 h-4 text-orange-600" />
                  </div>
                  <div className="flex items-center">
                    <h3 className="text-base font-semibold text-[#36322F]">Semantic Search</h3>
                  </div>
                </div>
                
                <div className="bg-[#FBFAF9] rounded-xl border border-gray-200 px-6 py-4 flex items-center gap-3 hover:shadow-sm transition-shadow">
                  <div className="w-8 h-8 bg-orange-100 rounded-lg flex items-center justify-center flex-shrink-0">
                    <Zap className="w-4 h-4 text-orange-600" />
                  </div>
                  <div className="flex items-center">
                    <h3 className="text-base font-semibold text-[#36322F]">RAG Pipeline</h3>
                  </div>
                </div>
                
                <div className="bg-[#FBFAF9] rounded-xl border border-gray-200 px-6 py-4 flex items-center gap-3 hover:shadow-sm transition-shadow">
                  <div className="w-8 h-8 bg-orange-100 rounded-lg flex items-center justify-center flex-shrink-0">
                    <Sparkles className="w-4 h-4 text-orange-600" />
                  </div>
                  <div className="flex items-center">
                    <h3 className="text-base font-semibold text-[#36322F]">Instant API</h3>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </>
      )}

      {/* API Key Modal */}
      <Dialog open={showApiKeyModal} onOpenChange={setShowApiKeyModal}>
        <DialogContent className="sm:max-w-md bg-white dark:bg-zinc-900">
          <DialogHeader>
            <DialogTitle>Firecrawl API Key Required</DialogTitle>
            <DialogDescription>
              This tool requires a Firecrawl API key to crawl and index websites.
            </DialogDescription>
          </DialogHeader>
          <div className="flex flex-col gap-4 py-4">
            <Button
              onClick={() => window.open('https://www.firecrawl.dev', '_blank')}
              variant="outline"
              size="sm"
              className="flex items-center justify-center gap-2 cursor-pointer"
            >
              <ExternalLink className="h-4 w-4" />
              Get Firecrawl API Key
            </Button>
            <div className="flex flex-col gap-2">
              <label htmlFor="firecrawl-key" className="text-sm font-medium">
                Firecrawl API Key
              </label>
              <Input
                id="firecrawl-key"
                type="password"
                placeholder="fc-..."
                value={firecrawlApiKey}
                onChange={(e) => setFirecrawlApiKey(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && !isValidatingApiKey) {
                    handleApiKeySubmit();
                  }
                }}
                disabled={isValidatingApiKey}
              />
            </div>
          </div>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setShowApiKeyModal(false)}
              disabled={isValidatingApiKey}
            >
              Cancel
            </Button>
            <Button
              onClick={handleApiKeySubmit}
              disabled={isValidatingApiKey || !firecrawlApiKey.trim()}
              variant="default"
            >
              {isValidatingApiKey ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Validating...
                </>
              ) : (
                'Submit'
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

================
File: components/ui/alert-dialog.tsx
================
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

================
File: components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        code: "h-9 px-4 rounded-[10px] text-sm font-medium items-center transition-all duration-200 disabled:cursor-not-allowed disabled:opacity-50 bg-[#36322F] text-[#fff] hover:bg-[#4a4542] disabled:bg-[#8c8885] disabled:hover:bg-[#8c8885] [box-shadow:inset_0px_-2.108433723449707px_0px_0px_#171310,_0px_1.2048193216323853px_6.325301647186279px_0px_rgba(58,_33,_8,_58%)] hover:translate-y-[1px] hover:scale-[0.98] hover:[box-shadow:inset_0px_-1px_0px_0px_#171310,_0px_1px_3px_0px_rgba(58,_33,_8,_40%)] active:translate-y-[2px] active:scale-[0.97] active:[box-shadow:inset_0px_1px_1px_0px_#171310,_0px_1px_2px_0px_rgba(58,_33,_8,_30%)] disabled:shadow-none disabled:hover:translate-y-0 disabled:hover:scale-100",
        orange: "h-9 px-4 rounded-[10px] text-sm font-medium items-center transition-all duration-200 disabled:cursor-not-allowed disabled:opacity-50 bg-orange-500 text-white hover:bg-orange-300 dark:bg-orange-500 dark:hover:bg-orange-300 dark:text-white [box-shadow:inset_0px_-2.108433723449707px_0px_0px_#c2410c,_0px_1.2048193216323853px_6.325301647186279px_0px_rgba(234,_88,_12,_58%)] hover:translate-y-[1px] hover:scale-[0.98] hover:[box-shadow:inset_0px_-1px_0px_0px_#c2410c,_0px_1px_3px_0px_rgba(234,_88,_12,_40%)] active:translate-y-[2px] active:scale-[0.97] active:[box-shadow:inset_0px_1px_1px_0px_#c2410c,_0px_1px_2px_0px_rgba(234,_88,_12,_30%)] disabled:shadow-none disabled:hover:translate-y-0 disabled:hover:scale-100",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: components/ui/dialog.tsx
================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}

================
File: components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }

================
File: components/ui/menubar.tsx
================
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Menubar({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Root>) {
  return (
    <MenubarPrimitive.Root
      data-slot="menubar"
      className={cn(
        "bg-background flex h-9 items-center gap-1 rounded-md border p-1 shadow-xs",
        className
      )}
      {...props}
    />
  )
}

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu data-slot="menubar-menu" {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group data-slot="menubar-group" {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal data-slot="menubar-portal" {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return (
    <MenubarPrimitive.RadioGroup data-slot="menubar-radio-group" {...props} />
  )
}

function MenubarTrigger({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Trigger>) {
  return (
    <MenubarPrimitive.Trigger
      data-slot="menubar-trigger"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex items-center rounded-sm px-2 py-1 text-sm font-medium outline-hidden select-none",
        className
      )}
      {...props}
    />
  )
}

function MenubarContent({
  className,
  align = "start",
  alignOffset = -4,
  sideOffset = 8,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Content>) {
  return (
    <MenubarPortal>
      <MenubarPrimitive.Content
        data-slot="menubar-content"
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[12rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </MenubarPortal>
  )
}

function MenubarItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <MenubarPrimitive.Item
      data-slot="menubar-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function MenubarCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.CheckboxItem>) {
  return (
    <MenubarPrimitive.CheckboxItem
      data-slot="menubar-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.CheckboxItem>
  )
}

function MenubarRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioItem>) {
  return (
    <MenubarPrimitive.RadioItem
      data-slot="menubar-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.RadioItem>
  )
}

function MenubarLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.Label
      data-slot="menubar-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function MenubarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Separator>) {
  return (
    <MenubarPrimitive.Separator
      data-slot="menubar-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function MenubarShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="menubar-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

function MenubarSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.SubTrigger
      data-slot="menubar-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto h-4 w-4" />
    </MenubarPrimitive.SubTrigger>
  )
}

function MenubarSubContent({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubContent>) {
  return (
    <MenubarPrimitive.SubContent
      data-slot="menubar-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  Menubar,
  MenubarPortal,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarGroup,
  MenubarSeparator,
  MenubarLabel,
  MenubarItem,
  MenubarShortcut,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSub,
  MenubarSubTrigger,
  MenubarSubContent,
}

================
File: components/ui/navigation-menu.tsx
================
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function NavigationMenu({
  className,
  children,
  viewport = true,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Root> & {
  viewport?: boolean
}) {
  return (
    <NavigationMenuPrimitive.Root
      data-slot="navigation-menu"
      data-viewport={viewport}
      className={cn(
        "group/navigation-menu relative flex max-w-max flex-1 items-center justify-center",
        className
      )}
      {...props}
    >
      {children}
      {viewport && <NavigationMenuViewport />}
    </NavigationMenuPrimitive.Root>
  )
}

function NavigationMenuList({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.List>) {
  return (
    <NavigationMenuPrimitive.List
      data-slot="navigation-menu-list"
      className={cn(
        "group flex flex-1 list-none items-center justify-center gap-1",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuItem({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Item>) {
  return (
    <NavigationMenuPrimitive.Item
      data-slot="navigation-menu-item"
      className={cn("relative", className)}
      {...props}
    />
  )
}

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 outline-none transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1"
)

function NavigationMenuTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Trigger>) {
  return (
    <NavigationMenuPrimitive.Trigger
      data-slot="navigation-menu-trigger"
      className={cn(navigationMenuTriggerStyle(), "group", className)}
      {...props}
    >
      {children}{" "}
      <ChevronDownIcon
        className="relative top-[1px] ml-1 size-3 transition duration-300 group-data-[state=open]:rotate-180"
        aria-hidden="true"
      />
    </NavigationMenuPrimitive.Trigger>
  )
}

function NavigationMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Content>) {
  return (
    <NavigationMenuPrimitive.Content
      data-slot="navigation-menu-content"
      className={cn(
        "data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 top-0 left-0 w-full p-2 pr-2.5 md:absolute md:w-auto",
        "group-data-[viewport=false]/navigation-menu:bg-popover group-data-[viewport=false]/navigation-menu:text-popover-foreground group-data-[viewport=false]/navigation-menu:data-[state=open]:animate-in group-data-[viewport=false]/navigation-menu:data-[state=closed]:animate-out group-data-[viewport=false]/navigation-menu:data-[state=closed]:zoom-out-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:zoom-in-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:fade-in-0 group-data-[viewport=false]/navigation-menu:data-[state=closed]:fade-out-0 group-data-[viewport=false]/navigation-menu:top-full group-data-[viewport=false]/navigation-menu:mt-1.5 group-data-[viewport=false]/navigation-menu:overflow-hidden group-data-[viewport=false]/navigation-menu:rounded-md group-data-[viewport=false]/navigation-menu:border group-data-[viewport=false]/navigation-menu:shadow group-data-[viewport=false]/navigation-menu:duration-200 **:data-[slot=navigation-menu-link]:focus:ring-0 **:data-[slot=navigation-menu-link]:focus:outline-none",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuViewport({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Viewport>) {
  return (
    <div
      className={cn(
        "absolute top-full left-0 isolate z-50 flex justify-center"
      )}
    >
      <NavigationMenuPrimitive.Viewport
        data-slot="navigation-menu-viewport"
        className={cn(
          "origin-top-center bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border shadow md:w-[var(--radix-navigation-menu-viewport-width)]",
          className
        )}
        {...props}
      />
    </div>
  )
}

function NavigationMenuLink({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Link>) {
  return (
    <NavigationMenuPrimitive.Link
      data-slot="navigation-menu-link"
      className={cn(
        "data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus-visible:ring-ring/50 [&_svg:not([class*='text-'])]:text-muted-foreground flex flex-col gap-1 rounded-sm p-2 text-sm transition-all outline-none focus-visible:ring-[3px] focus-visible:outline-1 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuIndicator({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Indicator>) {
  return (
    <NavigationMenuPrimitive.Indicator
      data-slot="navigation-menu-indicator"
      className={cn(
        "data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden",
        className
      )}
      {...props}
    >
      <div className="bg-border relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm shadow-md" />
    </NavigationMenuPrimitive.Indicator>
  )
}

export {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
  navigationMenuTriggerStyle,
}

================
File: components/ui/pagination.tsx
================
import * as React from "react"
import {
  ChevronLeftIcon,
  ChevronRightIcon,
  MoreHorizontalIcon,
} from "lucide-react"

import { cn } from "@/lib/utils"
import { Button, buttonVariants } from "@/components/ui/button"

function Pagination({ className, ...props }: React.ComponentProps<"nav">) {
  return (
    <nav
      role="navigation"
      aria-label="pagination"
      data-slot="pagination"
      className={cn("mx-auto flex w-full justify-center", className)}
      {...props}
    />
  )
}

function PaginationContent({
  className,
  ...props
}: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="pagination-content"
      className={cn("flex flex-row items-center gap-1", className)}
      {...props}
    />
  )
}

function PaginationItem({ ...props }: React.ComponentProps<"li">) {
  return <li data-slot="pagination-item" {...props} />
}

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<React.ComponentProps<typeof Button>, "size"> &
  React.ComponentProps<"a">

function PaginationLink({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) {
  return (
    <a
      aria-current={isActive ? "page" : undefined}
      data-slot="pagination-link"
      data-active={isActive}
      className={cn(
        buttonVariants({
          variant: isActive ? "outline" : "ghost",
          size,
        }),
        className
      )}
      {...props}
    />
  )
}

function PaginationPrevious({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to previous page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pl-2.5", className)}
      {...props}
    >
      <ChevronLeftIcon />
      <span className="hidden sm:block">Previous</span>
    </PaginationLink>
  )
}

function PaginationNext({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to next page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pr-2.5", className)}
      {...props}
    >
      <span className="hidden sm:block">Next</span>
      <ChevronRightIcon />
    </PaginationLink>
  )
}

function PaginationEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      aria-hidden
      data-slot="pagination-ellipsis"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontalIcon className="size-4" />
      <span className="sr-only">More pages</span>
    </span>
  )
}

export {
  Pagination,
  PaginationContent,
  PaginationLink,
  PaginationItem,
  PaginationPrevious,
  PaginationNext,
  PaginationEllipsis,
}

================
File: components/ui/popover.tsx
================
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }

================
File: components/ui/progress.tsx
================
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn(
        "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",
        className
      )}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
}

export { Progress }

================
File: components/ui/radio-group.tsx
================
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  )
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
}

export { RadioGroup, RadioGroupItem }

================
File: components/ui/resizable.tsx
================
"use client"

import * as React from "react"
import { GripVerticalIcon } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

function ResizablePanelGroup({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) {
  return (
    <ResizablePrimitive.PanelGroup
      data-slot="resizable-panel-group"
      className={cn(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        className
      )}
      {...props}
    />
  )
}

function ResizablePanel({
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.Panel>) {
  return <ResizablePrimitive.Panel data-slot="resizable-panel" {...props} />
}

function ResizableHandle({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) {
  return (
    <ResizablePrimitive.PanelResizeHandle
      data-slot="resizable-handle"
      className={cn(
        "bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        className
      )}
      {...props}
    >
      {withHandle && (
        <div className="bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border">
          <GripVerticalIcon className="size-2.5" />
        </div>
      )}
    </ResizablePrimitive.PanelResizeHandle>
  )
}

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }

================
File: components/ui/scroll-area.tsx
================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }

================
File: components/ui/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}

================
File: components/ui/separator.tsx
================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }

================
File: components/ui/sheet.tsx
================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

================
File: components/ui/sidebar.tsx
================
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener("keydown", handleKeyDown)
    return () => window.removeEventListener("keydown", handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed"

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button"
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}

================
File: components/ui/skeleton.tsx
================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }

================
File: components/ui/slider.tsx
================
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max]
  )

  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={cn(
          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
        )}
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={cn(
            "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
        />
      ))}
    </SliderPrimitive.Root>
  )
}

export { Slider }

================
File: components/ui/sonner.tsx
================
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }

================
File: components/ui/switch.tsx
================
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }

================
File: components/ui/table.tsx
================
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

================
File: components/ui/tabs.tsx
================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: components/ui/textarea.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }

================
File: components/ui/toggle-group.tsx
================
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

function ToggleGroup({
  className,
  variant,
  size,
  children,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <ToggleGroupPrimitive.Root
      data-slot="toggle-group"
      data-variant={variant}
      data-size={size}
      className={cn(
        "group/toggle-group flex w-fit items-center rounded-md data-[variant=outline]:shadow-xs",
        className
      )}
      {...props}
    >
      <ToggleGroupContext.Provider value={{ variant, size }}>
        {children}
      </ToggleGroupContext.Provider>
    </ToggleGroupPrimitive.Root>
  )
}

function ToggleGroupItem({
  className,
  children,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Item> &
  VariantProps<typeof toggleVariants>) {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      data-slot="toggle-group-item"
      data-variant={context.variant || variant}
      data-size={context.size || size}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        "min-w-0 flex-1 shrink-0 rounded-none shadow-none first:rounded-l-md last:rounded-r-md focus:z-10 focus-visible:z-10 data-[variant=outline]:border-l-0 data-[variant=outline]:first:border-l",
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
}

export { ToggleGroup, ToggleGroupItem }

================
File: components/ui/toggle.tsx
================
"use client"

import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-9 px-2 min-w-9",
        sm: "h-8 px-1.5 min-w-8",
        lg: "h-10 px-2.5 min-w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Toggle({
  className,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof TogglePrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <TogglePrimitive.Root
      data-slot="toggle"
      className={cn(toggleVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Toggle, toggleVariants }

================
File: components/ui/tooltip.tsx
================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

================
File: hooks/use-mobile.ts
================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

================
File: hooks/useStorage.ts
================
import { useState, useEffect } from 'react'
import { IndexMetadata } from '@/lib/storage'

// Check if we should use Redis (server-side storage)
const useRedis = !!(process.env.NEXT_PUBLIC_UPSTASH_REDIS_REST_URL && process.env.NEXT_PUBLIC_UPSTASH_REDIS_REST_TOKEN)

export function useStorage() {
  const [indexes, setIndexes] = useState<IndexMetadata[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchIndexes = async () => {
    setLoading(true)
    setError(null)
    
    try {
      if (useRedis) {
        // Fetch from API endpoint
        const response = await fetch('/api/indexes')
        if (!response.ok) {
          throw new Error('Failed to fetch indexes')
        }
        const data = await response.json()
        setIndexes(data.indexes || [])
      } else {
        // Use localStorage
        const stored = localStorage.getItem('firestarter_indexes')
        setIndexes(stored ? JSON.parse(stored) : [])
      }
    } catch (err) {
      console.error('Error fetching indexes:', err)
      setError(err instanceof Error ? err.message : 'Failed to fetch indexes')
      setIndexes([])
    } finally {
      setLoading(false)
    }
  }

  const saveIndex = async (index: IndexMetadata) => {
    try {
      if (useRedis) {
        // Save via API endpoint
        const response = await fetch('/api/indexes', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(index)
        })
        if (!response.ok) {
          throw new Error('Failed to save index')
        }
        // Refresh indexes
        await fetchIndexes()
      } else {
        // Save to localStorage
        const currentIndexes = [...indexes]
        const existingIndex = currentIndexes.findIndex(i => i.namespace === index.namespace)
        
        if (existingIndex !== -1) {
          currentIndexes[existingIndex] = index
        } else {
          currentIndexes.unshift(index)
        }
        
        // Keep only the last 50 indexes
        const limitedIndexes = currentIndexes.slice(0, 50)
        localStorage.setItem('firestarter_indexes', JSON.stringify(limitedIndexes))
        setIndexes(limitedIndexes)
      }
    } catch (err) {
      console.error('Error saving index:', err)
      throw err
    }
  }

  const deleteIndex = async (namespace: string) => {
    try {
      if (useRedis) {
        // Delete via API endpoint
        const response = await fetch(`/api/indexes?namespace=${namespace}`, {
          method: 'DELETE'
        })
        if (!response.ok) {
          throw new Error('Failed to delete index')
        }
        // Refresh indexes
        await fetchIndexes()
      } else {
        // Delete from localStorage
        const filteredIndexes = indexes.filter(i => i.namespace !== namespace)
        localStorage.setItem('firestarter_indexes', JSON.stringify(filteredIndexes))
        setIndexes(filteredIndexes)
      }
    } catch (err) {
      console.error('Error deleting index:', err)
      throw err
    }
  }

  useEffect(() => {
    fetchIndexes()
  }, [])

  return {
    indexes,
    loading,
    error,
    saveIndex,
    deleteIndex,
    refresh: fetchIndexes,
    isUsingRedis: useRedis
  }
}

================
File: lib/utils/source-context.ts
================
export interface SourceContext {
  url: string;
  snippet: string;
  confidence: number;
}

export function findRelevantSnippet(
  content: string,
  value: string | number | boolean | string[],
  fieldName: string,
  contextWindow: number = 200
): string {
  if (typeof value === 'boolean' || !content || !value || Array.isArray(value)) {
    return '';
  }
  
  const searchValue = String(value).toLowerCase();
  const contentLower = content.toLowerCase();
  
  // For numeric values, be more strict
  let index = -1;
  
  if (typeof value === 'number') {
    // For numbers, look for exact matches with word boundaries
    const numberPatterns = [
      searchValue, // exact number
      searchValue.replace(/000$/g, 'k'), // 1000 -> 1k
      searchValue.replace(/000000$/g, 'm'), // 1000000 -> 1m
      Number(value).toLocaleString(), // 1000 -> 1,000
    ];
    
    for (const pattern of numberPatterns) {
      // Use regex to ensure we're not matching part of a larger number
      const regex = new RegExp(`\\b${pattern}\\b`, 'i');
      const match = content.match(regex);
      if (match && match.index !== undefined) {
        index = match.index;
        break;
      }
    }
  } else {
    // For strings, try exact match first
    index = contentLower.indexOf(searchValue);
    
    // If no exact match, try to find partial matches for longer values
    if (index === -1 && searchValue.length > 20) {
      const words = searchValue.split(/\s+/).filter(w => w.length > 3);
      for (const word of words) {
        const wordIndex = contentLower.indexOf(word);
        if (wordIndex !== -1) {
          index = wordIndex;
          break;
        }
      }
    }
  }
  
  // Only fall back to field name search if we're looking for non-numeric values
  if (index === -1 && typeof value !== 'number') {
    // Try to find field name context
    const fieldNameVariations = [
      fieldName.toLowerCase(),
      fieldName.replace(/_/g, ' ').toLowerCase(),
      fieldName.replace(/([A-Z])/g, ' $1').toLowerCase().trim()
    ];
    
    for (const variation of fieldNameVariations) {
      const fieldIndex = contentLower.indexOf(variation);
      if (fieldIndex !== -1) {
        index = fieldIndex;
        break;
      }
    }
  }
  
  if (index === -1) {
    return '';
  }
  
  // Extract snippet with context
  const start = Math.max(0, index - contextWindow);
  const end = Math.min(content.length, index + searchValue.length + contextWindow);
  
  let snippet = content.substring(start, end);
  
  // Add ellipsis if truncated
  if (start > 0) snippet = '...' + snippet;
  if (end < content.length) snippet = snippet + '...';
  
  // Clean up whitespace
  snippet = snippet.replace(/\s+/g, ' ').trim();
  
  return snippet;
}

export function highlightValue(snippet: string, value: string): string {
  if (!snippet || !value) return snippet;
  
  const escapedValue = value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex = new RegExp(`(${escapedValue})`, 'gi');
  
  return snippet.replace(regex, '**$1**');
}

================
File: lib/error-handler.ts
================
import { v4 as uuidv4 } from 'uuid';
import { NextResponse } from 'next/server';

// Define error types for consistent user-facing messages
export enum ErrorType {
  VALIDATION = 'VALIDATION',
  AUTHENTICATION = 'AUTHENTICATION',
  AUTHORIZATION = 'AUTHORIZATION',
  RATE_LIMIT = 'RATE_LIMIT',
  NOT_FOUND = 'NOT_FOUND',
  API_ERROR = 'API_ERROR',
  SERVER_ERROR = 'SERVER_ERROR'
}

// Map error types to appropriate HTTP status codes
const errorStatusCodes: Record<ErrorType, number> = {
  [ErrorType.VALIDATION]: 400,
  [ErrorType.AUTHENTICATION]: 401,
  [ErrorType.AUTHORIZATION]: 403,
  [ErrorType.RATE_LIMIT]: 429,
  [ErrorType.NOT_FOUND]: 404,
  [ErrorType.API_ERROR]: 502,
  [ErrorType.SERVER_ERROR]: 500
};

// Map error types to user-friendly messages
const errorMessages: Record<ErrorType, string> = {
  [ErrorType.VALIDATION]: 'Invalid request data. Please check your input and try again.',
  [ErrorType.AUTHENTICATION]: 'Authentication required. Please provide valid credentials.',
  [ErrorType.AUTHORIZATION]: 'You do not have permission to perform this action.',
  [ErrorType.RATE_LIMIT]: 'Rate limit exceeded. Please try again later.',
  [ErrorType.NOT_FOUND]: 'The requested resource was not found.',
  [ErrorType.API_ERROR]: 'Error communicating with external service. Please try again later.',
  [ErrorType.SERVER_ERROR]: 'An unexpected error occurred. Please try again later.'
};

// Helper function to handle errors in a consistent way
export function handleError(
  error: unknown, 
  errorType: ErrorType = ErrorType.SERVER_ERROR, 
  context: string = 'API',
  additionalInfo: Record<string, unknown> = {}
) {
  // Generate a correlation ID for tracing
  const correlationId = uuidv4();
  
  // Get error message if available
  const errorMessage = error instanceof Error ? error.message : String(error);
  
  // Build the log object with all relevant information
  const logData = {
    timestamp: new Date().toISOString(),
    correlationId,
    context,
    errorType,
    errorMessage,
    stack: error instanceof Error ? error.stack : undefined,
    ...additionalInfo
  };
  
  // Log the full error details for debugging
  if (process.env.NODE_ENV === 'production') {
    // In production, use structured logging
    console.error(JSON.stringify(logData));
  } else {
    // In development, make it more readable
    console.error(`[${logData.context}] Error (${correlationId}):`, error);
    console.error('Additional info:', additionalInfo);
  }
  
  // Return a sanitized error response for the client
  return {
    status: errorStatusCodes[errorType],
    body: {
      error: {
        message: errorMessages[errorType],
        correlationId,
        type: errorType
      }
    }
  };
}

// Helper function specifically for Next.js API routes returning NextResponse
export function handleNextError(
  error: unknown, 
  errorType: ErrorType = ErrorType.SERVER_ERROR, 
  context: string = 'API',
  additionalInfo: Record<string, unknown> = {}
) {
  const { status, body } = handleError(error, errorType, context, additionalInfo);
  return NextResponse.json(body, { status });
}

// Helper function specifically for Edge Runtime API routes
export function handleEdgeError(
  error: unknown, 
  errorType: ErrorType = ErrorType.SERVER_ERROR, 
  context: string = 'API',
  additionalInfo: Record<string, unknown> = {}
) {
  const { status, body } = handleError(error, errorType, context, additionalInfo);
  return new Response(JSON.stringify(body), {
    status,
    headers: {
      'Content-Type': 'application/json'
    }
  });
}

================
File: lib/firecrawl.ts
================
/* eslint-disable @typescript-eslint/no-explicit-any */
import FirecrawlApp from '@mendable/firecrawl-js';

export class FirecrawlClient {
  private client: FirecrawlApp;

  constructor(providedApiKey?: string) {
    const apiKey = providedApiKey || process.env.FIRECRAWL_API_KEY;
    if (!apiKey) {
      throw new Error('FIRECRAWL_API_KEY is required - either provide it or set it as an environment variable');
    }
    this.client = new FirecrawlApp({ apiKey });
  }

  async scrapeUrl(url: string, timeoutMs: number = 15000) {
    try {
      // Create a timeout promise
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Scraping timeout')), timeoutMs);
      });
      
      // Race the scraping against the timeout
      const scrapePromise = this.client.scrapeUrl(url, {
        formats: ['markdown', 'html'],
      });
      
      const result = await Promise.race([scrapePromise, timeoutPromise]) as any;
      
      if ('success' in result && !result.success) {
        throw new Error(result.error || 'Scrape failed');
      }
      
      return {
        markdown: (result as any).markdown || '',
        html: (result as any).html || '',
        metadata: (result as any).metadata || {},
        success: true,
      };
    } catch (error: any) {
      console.error('Firecrawl scrape error:', error);
      
      // Handle timeout errors
      if (error?.message === 'Scraping timeout') {
        return {
          markdown: '',
          html: '',
          metadata: {
            error: 'Scraping took too long and was stopped',
            timeout: true,
          },
          success: false,
          error: 'timeout',
        };
      }
      
      // Handle 403 errors gracefully
      if (error?.statusCode === 403 || error?.message?.includes('403')) {
        return {
          markdown: '',
          html: '',
          metadata: {
            error: 'This website is not supported by Firecrawl',
            statusCode: 403,
          },
          success: false,
          error: 'unsupported',
        };
      }
      
      // Return error info for other failures
      return {
        markdown: '',
        html: '',
        metadata: {
          error: error?.message || 'Failed to scrape URL',
          statusCode: error?.statusCode,
        },
        success: false,
        error: 'failed',
      };
    }
  }

  async mapUrl(url: string, options?: { search?: string; limit?: number }) {
    try {
      const result = await this.client.mapUrl(url, {
        search: options?.search,
        limit: options?.limit || 10,
      });
      
      if ('success' in result && !result.success) {
        throw new Error((result as any).error || 'Map failed');
      }
      
      return {
        links: (result as any).links || [],
        metadata: (result as any).metadata || {},
      };
    } catch (error) {
      console.error('Firecrawl map error:', error);
      throw error;
    }
  }

  async search(query: string, options?: { limit?: number; scrapeOptions?: any }) {
    try {
      // Search with scrape - this gets us content immediately!
      const searchParams: any = {
        limit: options?.limit || 10,
      };
      
      // Add scrapeOptions to get content with search results
      if (options?.scrapeOptions !== false) {
        searchParams.scrapeOptions = {
          formats: ['markdown'],
          ...options?.scrapeOptions
        };
      }
      
      console.log('[Firecrawl] Searching for:', query);
      console.log('[Firecrawl] Search params:', JSON.stringify(searchParams, null, 2));
      console.log('[Firecrawl] API Key present:', !!this.client);
      
      const result = await this.client.search(query, searchParams);
      
      // Log for debugging
      console.log('[Firecrawl] Raw search response type:', typeof result);
      console.log('[Firecrawl] Raw search response keys:', result ? Object.keys(result) : 'null');
      console.log('[Firecrawl] Search response success:', result?.success);
      console.log('[Firecrawl] Search response data length:', result?.data?.length);
      console.log('[Firecrawl] First result sample:', result?.data?.[0] ? {
        url: result.data[0].url,
        title: result.data[0].title,
        hasMarkdown: !!result.data[0].markdown,
        markdownLength: result.data[0].markdown?.length
      } : 'No data');
      
      // Handle the actual Firecrawl v1 API response format
      if (result && typeof result === 'object' && 'success' in result) {
        if (!(result as any).success) {
          throw new Error((result as any).error || 'Search failed');
        }
      }
      
      // Extract data - search with scrape returns data with content
      const data = (result as any)?.data || [];
      
      // Transform to include scraped content
      const enrichedData = data.map((item: any) => {
        // Try to extract favicon from metadata or construct default
        let favicon = item.metadata?.favicon || null;
        if (!favicon && item.metadata?.ogImage) {
          favicon = item.metadata.ogImage;
        } else if (!favicon && item.url) {
          // Default favicon URL
          const domain = new URL(item.url).hostname;
          favicon = `https://${domain}/favicon.ico`;
        }
        
        return {
          url: item.url,
          title: item.title || item.metadata?.title || 'Untitled',
          description: item.description || item.metadata?.description || '',
          markdown: item.markdown || '',
          html: item.html || '',
          links: item.links || [],
          screenshot: item.screenshot || null,
          metadata: {
            ...item.metadata,
            favicon: favicon,
            screenshot: item.screenshot
          },
          scraped: true, // Mark as already scraped
          content: item.markdown || '', // For compatibility
          favicon: favicon // Add at top level for easy access
        };
      });
      
      return {
        data: enrichedData,
        results: enrichedData, // For backward compatibility
        metadata: (result as any)?.metadata || {},
      };
    } catch (error) {
      console.error('Firecrawl search error:', error);
      throw error;
    }
  }
}

================
File: lib/langgraph-search-engine.ts
================
import { StateGraph, END, START, Annotation, MemorySaver } from "@langchain/langgraph";
import { ChatOpenAI } from "@langchain/openai";
import { HumanMessage, SystemMessage } from "@langchain/core/messages";
import { FirecrawlClient } from './firecrawl';
import { ContextProcessor } from './context-processor';

// Configuration constants
const SEARCH_CONFIG = {
  MAX_SEARCH_QUERIES: 12,
  MAX_SOURCES_PER_SEARCH: 10,
  MAX_SOURCES_TO_SCRAPE: 10,
  MIN_CONTENT_LENGTH: 100,
  MAX_RETRIES: 2,
  SUMMARY_CHAR_LIMIT: 100,
  CONTEXT_PREVIEW_LENGTH: 500,
  SCRAPE_TIMEOUT: 15000
} as const;

// Event types remain the same for frontend compatibility
export type SearchPhase = 
  | 'understanding'
  | 'planning' 
  | 'searching'
  | 'analyzing'
  | 'synthesizing'
  | 'complete'
  | 'error';

export type SearchEvent = 
  | { type: 'phase-update'; phase: SearchPhase; message: string }
  | { type: 'thinking'; message: string }
  | { type: 'searching'; query: string; index: number; total: number }
  | { type: 'found'; sources: Source[]; query: string }
  | { type: 'scraping'; url: string; index: number; total: number; query: string }
  | { type: 'content-chunk'; chunk: string }
  | { type: 'final-result'; content: string; sources: Source[]; followUpQuestions?: string[] }
  | { type: 'error'; error: string; errorType?: ErrorType };

export type ErrorType = 'search' | 'scrape' | 'llm' | 'unknown';

export interface Source {
  url: string;
  title: string;
  content?: string;
  quality?: number;
}

export interface SearchResult {
  url: string;
  title: string;
  content?: string;
  markdown?: string;
}

export interface SearchStep {
  id: SearchPhase | string;
  label: string;
  status: 'pending' | 'active' | 'completed';
  startTime?: number;
}

// Proper LangGraph state using Annotation with reducers
const SearchStateAnnotation = Annotation.Root({
  // Input fields
  query: Annotation<string>({
    reducer: (_, y) => y ?? "",
    default: () => ""
  }),
  context: Annotation<{ query: string; response: string }[] | undefined>({
    reducer: (_, y) => y,
    default: () => undefined
  }),
  
  // Process fields
  understanding: Annotation<string | undefined>({
    reducer: (x, y) => y ?? x,
    default: () => undefined
  }),
  searchQueries: Annotation<string[] | undefined>({
    reducer: (x, y) => y ?? x,
    default: () => undefined
  }),
  currentSearchIndex: Annotation<number>({
    reducer: (x, y) => y ?? x,
    default: () => 0
  }),
  
  // Results fields - with proper array reducers
  sources: Annotation<Source[]>({
    reducer: (existing: Source[], update: Source[] | undefined) => {
      if (!update) return existing;
      return [...existing, ...update];
    },
    default: () => []
  }),
  scrapedSources: Annotation<Source[]>({
    reducer: (existing: Source[], update: Source[] | undefined) => {
      if (!update) return existing;
      return [...existing, ...update];
    },
    default: () => []
  }),
  processedSources: Annotation<Source[] | undefined>({
    reducer: (x, y) => y ?? x,
    default: () => undefined
  }),
  finalAnswer: Annotation<string | undefined>({
    reducer: (x, y) => y ?? x,
    default: () => undefined
  }),
  followUpQuestions: Annotation<string[] | undefined>({
    reducer: (x, y) => y ?? x,
    default: () => undefined
  }),
  
  // Control fields
  phase: Annotation<SearchPhase>({
    reducer: (x, y) => y ?? x,
    default: () => 'understanding' as SearchPhase
  }),
  error: Annotation<string | undefined>({
    reducer: (x, y) => y ?? x,
    default: () => undefined
  }),
  errorType: Annotation<ErrorType | undefined>({
    reducer: (x, y) => y ?? x,
    default: () => undefined
  }),
  maxRetries: Annotation<number>({
    reducer: (x, y) => y ?? x,
    default: () => SEARCH_CONFIG.MAX_RETRIES
  }),
  retryCount: Annotation<number>({
    reducer: (x, y) => y ?? x,
    default: () => 0
  })
});

type SearchState = typeof SearchStateAnnotation.State;

// Define config type for proper event handling
interface GraphConfig {
  configurable?: {
    eventCallback?: (event: SearchEvent) => void;
    checkpointId?: string;
  };
}

export class LangGraphSearchEngine {
  private firecrawl: FirecrawlClient;
  private contextProcessor: ContextProcessor;
  private graph: ReturnType<typeof this.buildGraph>;
  private llm: ChatOpenAI;
  private streamingLlm: ChatOpenAI;
  private checkpointer?: MemorySaver;

  constructor(firecrawl: FirecrawlClient, options?: { enableCheckpointing?: boolean }) {
    this.firecrawl = firecrawl;
    this.contextProcessor = new ContextProcessor();
    
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OPENAI_API_KEY environment variable is not set');
    }
    
    // Initialize LangChain models
    this.llm = new ChatOpenAI({
      modelName: "gpt-4o-mini",
      temperature: 0,
      openAIApiKey: apiKey,
    });
    
    this.streamingLlm = new ChatOpenAI({
      modelName: "gpt-4o",
      temperature: 0,
      streaming: true,
      openAIApiKey: apiKey,
    });

    // Enable checkpointing if requested
    if (options?.enableCheckpointing) {
      this.checkpointer = new MemorySaver();
    }
    
    this.graph = this.buildGraph();
  }

  getInitialSteps(): SearchStep[] {
    return [
      { id: 'understanding', label: 'Understanding request', status: 'pending' },
      { id: 'planning', label: 'Planning search', status: 'pending' },
      { id: 'searching', label: 'Searching sources', status: 'pending' },
      { id: 'analyzing', label: 'Analyzing content', status: 'pending' },
      { id: 'synthesizing', label: 'Synthesizing answer', status: 'pending' },
      { id: 'complete', label: 'Complete', status: 'pending' }
    ];
  }

  private buildGraph() {
    // Create closures for helper methods
    const analyzeQuery = this.analyzeQuery.bind(this);
    const generateSearchQueries = this.generateSearchQueries.bind(this);
    const scoreContent = this.scoreContent.bind(this);
    const summarizeContent = this.summarizeContent.bind(this);
    const generateStreamingAnswer = this.generateStreamingAnswer.bind(this);
    const generateFollowUpQuestions = this.generateFollowUpQuestions.bind(this);
    const firecrawl = this.firecrawl;
    const contextProcessor = this.contextProcessor;
    
    const workflow = new StateGraph(SearchStateAnnotation)
      // Understanding node
      .addNode("understand", async (state: SearchState, config?: GraphConfig): Promise<Partial<SearchState>> => {
        const eventCallback = config?.configurable?.eventCallback;
        
        if (eventCallback) {
          eventCallback({
            type: 'phase-update',
            phase: 'understanding',
            message: 'Analyzing your request...'
          });
        }
        
        try {
          const understanding = await analyzeQuery(state.query, state.context);
          
          if (eventCallback) {
            eventCallback({
              type: 'thinking',
              message: understanding
            });
          }
          
          return {
            understanding,
            phase: 'planning' as SearchPhase
          };
        } catch (error) {
          return {
            error: error instanceof Error ? error.message : 'Failed to understand query',
            errorType: 'llm' as ErrorType,
            phase: 'error' as SearchPhase
          };
        }
      })
      
      // Planning node
      .addNode("plan", async (state: SearchState, config?: GraphConfig): Promise<Partial<SearchState>> => {
        const eventCallback = config?.configurable?.eventCallback;
        
        if (eventCallback) {
          eventCallback({
            type: 'phase-update',
            phase: 'planning',
            message: 'Planning search strategy...'
          });
        }
        
        try {
          const searchQueries = await generateSearchQueries(state.query, state.context);
          
          if (eventCallback) {
            eventCallback({
              type: 'thinking',
              message: searchQueries.length > 3 
                ? `I detected ${searchQueries.length} different questions/topics. I'll search for each one separately.`
                : `I'll search for ${searchQueries.length} different aspects of your question`
            });
          }
          
          return {
            searchQueries,
            currentSearchIndex: 0,
            phase: 'searching' as SearchPhase
          };
        } catch (error) {
          return {
            error: error instanceof Error ? error.message : 'Failed to plan search',
            errorType: 'llm' as ErrorType,
            phase: 'error' as SearchPhase
          };
        }
      })
      
      // Search node (handles one search at a time)
      .addNode("search", async (state: SearchState, config?: GraphConfig): Promise<Partial<SearchState>> => {
        const eventCallback = config?.configurable?.eventCallback;
        const searchQueries = state.searchQueries || [];
        const currentIndex = state.currentSearchIndex || 0;
        
        if (currentIndex === 0 && eventCallback) {
          eventCallback({
            type: 'phase-update',
            phase: 'searching',
            message: 'Searching the web...'
          });
        }
        
        if (currentIndex >= searchQueries.length) {
          return {
            phase: 'scrape' as SearchPhase
          };
        }
        
        const searchQuery = searchQueries[currentIndex];
        
        if (eventCallback) {
          eventCallback({
            type: 'searching',
            query: searchQuery,
            index: currentIndex + 1,
            total: searchQueries.length
          });
        }
        
        try {
          const results = await firecrawl.search(searchQuery, {
            limit: SEARCH_CONFIG.MAX_SOURCES_PER_SEARCH,
            scrapeOptions: {
              formats: ['markdown']
            }
          });
          
          const newSources: Source[] = results.data.map((r: SearchResult) => ({
            url: r.url,
            title: r.title,
            content: r.markdown || r.content || '',
            quality: 0
          }));
          
          if (eventCallback) {
            eventCallback({
              type: 'found',
              sources: newSources,
              query: searchQuery
            });
          }
          
          return {
            sources: newSources,
            currentSearchIndex: currentIndex + 1
          };
        } catch (error) {
          console.error(`Search failed for query "${searchQuery}":`, error);
          return {
            currentSearchIndex: currentIndex + 1,
            errorType: 'search' as ErrorType
          };
        }
      })
      
      // Scraping node
      .addNode("scrape", async (state: SearchState, config?: GraphConfig): Promise<Partial<SearchState>> => {
        const eventCallback = config?.configurable?.eventCallback;
        const sourcesToScrape = state.sources?.filter(s => 
          !s.content || s.content.length < SEARCH_CONFIG.MIN_CONTENT_LENGTH
        ) || [];
        const newScrapedSources: Source[] = [];
        
        // Process sources that already have content
        const sourcesWithContent = state.sources?.filter(s => 
          s.content && s.content.length >= SEARCH_CONFIG.MIN_CONTENT_LENGTH
        ) || [];
        
        for (const source of sourcesWithContent) {
          source.quality = scoreContent(source.content || '', state.query);
          newScrapedSources.push(source);
          
          if (eventCallback) {
            eventCallback({
              type: 'scraping',
              url: source.url,
              index: newScrapedSources.length,
              total: sourcesWithContent.length + Math.min(sourcesToScrape.length, SEARCH_CONFIG.MAX_SOURCES_TO_SCRAPE),
              query: state.query
            });
          }
          
          const summary = await summarizeContent(source.content || '', state.query);
          if (summary && eventCallback) {
            eventCallback({
              type: 'thinking',
              message: summary
            });
          }
        }
        
        // Then scrape sources without content
        for (let i = 0; i < Math.min(sourcesToScrape.length, SEARCH_CONFIG.MAX_SOURCES_TO_SCRAPE); i++) {
          const source = sourcesToScrape[i];
          
          if (eventCallback) {
            eventCallback({
              type: 'scraping',
              url: source.url,
              index: newScrapedSources.length + 1,
              total: sourcesWithContent.length + Math.min(sourcesToScrape.length, SEARCH_CONFIG.MAX_SOURCES_TO_SCRAPE),
              query: state.query
            });
          }
          
          try {
            const scraped = await firecrawl.scrapeUrl(source.url, SEARCH_CONFIG.SCRAPE_TIMEOUT);
            if (scraped.success && scraped.markdown) {
              const enrichedSource = {
                ...source,
                content: scraped.markdown,
                quality: scoreContent(scraped.markdown, state.query)
              };
              newScrapedSources.push(enrichedSource);
              
              const summary = await summarizeContent(scraped.markdown, state.query);
              if (summary && eventCallback) {
                eventCallback({
                  type: 'thinking',
                  message: summary
                });
              }
            } else if (scraped.error === 'timeout') {
              console.warn(`Scraping ${source.url} timed out after ${SEARCH_CONFIG.SCRAPE_TIMEOUT}ms`);
              if (eventCallback) {
                eventCallback({
                  type: 'thinking',
                  message: `${new URL(source.url).hostname} is taking too long to respond, moving on...`
                });
              }
            }
          } catch (error) {
            console.warn(`Failed to scrape ${source.url}:`, error);
            if (eventCallback) {
              eventCallback({
                type: 'thinking',
                message: `Couldn't access ${new URL(source.url).hostname}, trying other sources...`
              });
            }
          }
        }
        
        return {
          scrapedSources: newScrapedSources,
          phase: 'analyzing' as SearchPhase
        };
      })
      
      // Analyzing node
      .addNode("analyze", async (state: SearchState, config?: GraphConfig): Promise<Partial<SearchState>> => {
        const eventCallback = config?.configurable?.eventCallback;
        
        if (eventCallback) {
          eventCallback({
            type: 'phase-update',
            phase: 'analyzing',
            message: 'Analyzing gathered information...'
          });
        }
        
        const allSources = [
          ...(state.sources || []).filter(s => s.content && s.content.length > SEARCH_CONFIG.MIN_CONTENT_LENGTH),
          ...(state.scrapedSources || [])
        ];
        
        if (eventCallback) {
          eventCallback({
            type: 'thinking',
            message: `Found ${allSources.length} relevant sources with quality information`
          });
        }
        
        // Process sources with context processor
        if (eventCallback) {
          eventCallback({
            type: 'thinking',
            message: `Processing ${allSources.length} sources with AI summarization for optimal relevance...`
          });
        }
        
        try {
          const processedSources = await contextProcessor.processSources(
            state.query,
            allSources,
            state.searchQueries || []
          );
          
          return {
            sources: allSources,
            processedSources,
            phase: 'synthesizing' as SearchPhase
          };
        } catch (error) {
          console.warn('Failed to process sources with context processor:', error);
          // Fallback to using all sources without processing
          return {
            sources: allSources,
            processedSources: allSources,
            phase: 'synthesizing' as SearchPhase
          };
        }
      })
      
      // Synthesizing node with streaming
      .addNode("synthesize", async (state: SearchState, config?: GraphConfig): Promise<Partial<SearchState>> => {
        const eventCallback = config?.configurable?.eventCallback;
        
        if (eventCallback) {
          eventCallback({
            type: 'phase-update',
            phase: 'synthesizing',
            message: 'Creating comprehensive answer...'
          });
        }
        
        try {
          const sourcesToUse = state.processedSources || state.sources || [];
          
          const answer = await generateStreamingAnswer(
            state.query,
            sourcesToUse,
            (chunk) => {
              if (eventCallback) {
                eventCallback({ type: 'content-chunk', chunk });
              }
            },
            state.context
          );
          
          // Generate follow-up questions
          const followUpQuestions = await generateFollowUpQuestions(
            state.query,
            answer,
            sourcesToUse,
            state.context
          );
          
          return {
            finalAnswer: answer,
            followUpQuestions,
            phase: 'complete' as SearchPhase
          };
        } catch (error) {
          return {
            error: error instanceof Error ? error.message : 'Failed to generate answer',
            errorType: 'llm' as ErrorType,
            phase: 'error' as SearchPhase
          };
        }
      })
      
      // Error handling node
      .addNode("handleError", async (state: SearchState, config?: GraphConfig): Promise<Partial<SearchState>> => {
        const eventCallback = config?.configurable?.eventCallback;
        
        if (eventCallback) {
          eventCallback({
            type: 'error',
            error: state.error || 'An unknown error occurred',
            errorType: state.errorType
          });
        }
        
        // Retry logic based on error type
        if ((state.retryCount || 0) < (state.maxRetries || SEARCH_CONFIG.MAX_RETRIES)) {
          console.log(`Retrying due to ${state.errorType} error... Attempt ${(state.retryCount || 0) + 1}`);
          
          // Different retry strategies based on error type
          const retryPhase = state.errorType === 'search' ? 'searching' : 'understanding';
          
          return {
            retryCount: (state.retryCount || 0) + 1,
            phase: retryPhase as SearchPhase,
            error: undefined,
            errorType: undefined
          };
        }
        
        return {
          phase: 'error' as SearchPhase
        };
      })
      
      // Complete node
      .addNode("complete", async (state: SearchState, config?: GraphConfig): Promise<Partial<SearchState>> => {
        const eventCallback = config?.configurable?.eventCallback;
        
        if (eventCallback) {
          eventCallback({
            type: 'phase-update',
            phase: 'complete',
            message: 'Search complete!'
          });
          
          eventCallback({
            type: 'final-result',
            content: state.finalAnswer || '',
            sources: state.sources || [],
            followUpQuestions: state.followUpQuestions
          });
        }
        
        return {
          phase: 'complete' as SearchPhase
        };
      });

    // Add edges with proper conditional routing
    workflow
      .addEdge(START, "understand")
      .addConditionalEdges(
        "understand",
        (state: SearchState) => state.phase === 'error' ? "handleError" : "plan",
        {
          handleError: "handleError",
          plan: "plan"
        }
      )
      .addConditionalEdges(
        "plan",
        (state: SearchState) => state.phase === 'error' ? "handleError" : "search",
        {
          handleError: "handleError",
          search: "search"
        }
      )
      .addConditionalEdges(
        "search",
        (state: SearchState) => {
          if (state.phase === 'error') return "handleError";
          if ((state.currentSearchIndex || 0) < (state.searchQueries?.length || 0)) {
            return "search"; // Continue searching
          }
          return "scrape"; // Move to scraping
        },
        {
          handleError: "handleError",
          search: "search",
          scrape: "scrape"
        }
      )
      .addConditionalEdges(
        "scrape",
        (state: SearchState) => state.phase === 'error' ? "handleError" : "analyze",
        {
          handleError: "handleError",
          analyze: "analyze"
        }
      )
      .addConditionalEdges(
        "analyze",
        (state: SearchState) => state.phase === 'error' ? "handleError" : "synthesize",
        {
          handleError: "handleError",
          synthesize: "synthesize"
        }
      )
      .addConditionalEdges(
        "synthesize",
        (state: SearchState) => state.phase === 'error' ? "handleError" : "complete",
        {
          handleError: "handleError",
          complete: "complete"
        }
      )
      .addConditionalEdges(
        "handleError",
        (state: SearchState) => state.phase === 'error' ? END : "understand",
        {
          [END]: END,
          understand: "understand"
        }
      )
      .addEdge("complete", END);

    // Compile with optional checkpointing
    return workflow.compile(this.checkpointer ? { checkpointer: this.checkpointer } : undefined);
  }

  async search(
    query: string,
    onEvent: (event: SearchEvent) => void,
    context?: { query: string; response: string }[],
    checkpointId?: string
  ): Promise<void> {
    try {
      const initialState: SearchState = {
        query,
        context,
        sources: [],
        scrapedSources: [],
        processedSources: undefined,
        phase: 'understanding',
        currentSearchIndex: 0,
        maxRetries: SEARCH_CONFIG.MAX_RETRIES,
        retryCount: 0,
        understanding: undefined,
        searchQueries: undefined,
        finalAnswer: undefined,
        followUpQuestions: undefined,
        error: undefined,
        errorType: undefined
      };

      // Configure with event callback
      const config: GraphConfig = {
        configurable: {
          eventCallback: onEvent,
          ...(checkpointId && this.checkpointer ? { thread_id: checkpointId } : {})
        }
      };

      // Invoke the graph - no need to iterate over stream since events are handled in nodes
      await this.graph.invoke(initialState, config);
    } catch (error) {
      onEvent({
        type: 'error',
        error: error instanceof Error ? error.message : 'Search failed',
        errorType: 'unknown'
      });
    }
  }

  // Compatibility method for SearchEngine interface
  private async simulateWork(ms: number): Promise<void> {
    await new Promise(resolve => setTimeout(resolve, ms));
  }

  // Get current date for context
  private getCurrentDateContext(): string {
    const now = new Date();
    const dateStr = now.toLocaleDateString('en-US', { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });
    const year = now.getFullYear();
    const month = now.getMonth() + 1;
    
    return `Today's date is ${dateStr}. The current year is ${year} and it's currently ${month}/${year}.`;
  }

  // Pure helper methods (no side effects)
  private async analyzeQuery(query: string, context?: { query: string; response: string }[]): Promise<string> {
    let contextPrompt = '';
    if (context && context.length > 0) {
      contextPrompt = '\n\nPrevious conversation:\n';
      context.forEach(c => {
        contextPrompt += `User: ${c.query}\nAssistant: ${c.response.substring(0, SEARCH_CONFIG.CONTEXT_PREVIEW_LENGTH)}...\n\n`;
      });
    }
    
    const messages = [
      new SystemMessage(`${this.getCurrentDateContext()}

Analyze this search query and explain what you understand the user is looking for.

Instructions:
- Start with a clear, concise title (e.g., "Researching egg shortage" or "Understanding climate change impacts")
- Then explain in 1-2 sentences what aspects of the topic the user wants to know about
- If this relates to previous questions, acknowledge that connection
- Finally, mention that you'll search for information to help answer their question
- Only mention searching for "latest" information if the query is explicitly about recent events or current trends

Keep it natural and conversational, showing you truly understand their request.`),
      new HumanMessage(`Query: "${query}"${contextPrompt}`)
    ];
    
    const response = await this.llm.invoke(messages);
    return response.content.toString();
  }

  private async generateSearchQueries(query: string, context?: { query: string; response: string }[]): Promise<string[]> {
    let contextPrompt = '';
    if (context && context.length > 0) {
      contextPrompt = '\n\nPrevious conversation context:\n';
      context.forEach(c => {
        const limitedResponse = c.response.length > 500 
          ? c.response.slice(0, 500) + '...' 
          : c.response;
        contextPrompt += `User: ${c.query}\nAssistant discussed: ${limitedResponse}\n\n`;
      });
      contextPrompt += '\nIf the current query refers to items from the previous conversation, make sure to include those specific items in your search queries.\n';
    }
    
    const messages = [
      new SystemMessage(`Analyze this query and generate appropriate search queries.

CRITICAL: DO NOT add years, dates, or temporal qualifiers (like "2024", "2025", "latest", "current") to search queries UNLESS the user's query explicitly contains words like "latest", "current", "recent", "new", "2024", "2025", etc.

Instructions:
- For simple queries (e.g., "What is X?")  use just 1 search
- For queries with multiple distinct questions  create a separate search for EACH question
- For lists or multiple items  create individual searches for each item
- Don't artificially group unrelated topics together
- Each search should be focused and specific
- If the query refers to previous context, include the specific items from context

Examples:
- "What is firecrawl?"  1 search: "firecrawl overview features documentation"
- "Who is John Doe?"  1 search: "who is John Doe"
- "What is X? How does Y work? Where to buy Z?"  3 separate searches
- "Tell me about A, B, C, D, and E"  5 separate searches (one for each)
- "Compare React vs Vue vs Angular"  3 searches (one for each framework)
- "What are the latest programming languages?"  1 search: "latest programming languages 2024"
- "Current AI trends"  1 search: "current AI trends 2024"

Important: If the user asks about multiple distinct things, create separate searches. Don't force them into fewer searches.

Return only the search queries, one per line.`),
      new HumanMessage(`Query: "${query}"${contextPrompt}`)
    ];
    
    const response = await this.llm.invoke(messages);
    const result = response.content.toString();
    
    const queries = result
      .split('\n')
      .map(q => q.trim())
      .map(q => q.replace(/^["']|["']$/g, ''))
      .filter(q => q.length > 0)
      .filter(q => !q.match(/^```/))
      .filter(q => !q.match(/^[-*#]/))
      .filter(q => q.length > 3);
    
    return queries.slice(0, SEARCH_CONFIG.MAX_SEARCH_QUERIES);
  }

  private scoreContent(content: string, query: string): number {
    const queryWords = query.toLowerCase().split(' ');
    const contentLower = content.toLowerCase();
    
    let score = 0;
    for (const word of queryWords) {
      if (contentLower.includes(word)) score += 0.2;
    }
    
    return Math.min(score, 1);
  }

  private async summarizeContent(content: string, query: string): Promise<string> {
    try {
      const messages = [
        new SystemMessage(`${this.getCurrentDateContext()}

Extract one key finding from this content that's relevant to the search query.

Instructions:
- Return just ONE sentence summarizing the most important finding
- Make it specific and factual (include numbers, dates, or specific details if relevant)
- Keep it under ${SEARCH_CONFIG.SUMMARY_CHAR_LIMIT} characters
- Don't include any prefixes like "The article states" or "According to"`),
        new HumanMessage(`Query: "${query}"\n\nContent: ${content.slice(0, 2000)}`)
      ];
      
      const response = await this.llm.invoke(messages);
      return response.content.toString().trim();
    } catch (error) {
      console.warn('Failed to summarize content:', error);
      return '';
    }
  }

  private async generateStreamingAnswer(
    query: string,
    sources: Source[],
    onChunk: (chunk: string) => void,
    context?: { query: string; response: string }[]
  ): Promise<string> {
    const sourcesText = sources
      .map((s, i) => {
        if (!s.content) return `[${i + 1}] ${s.title}\n[No content available]`;
        return `[${i + 1}] ${s.title}\n${s.content}`;
      })
      .join('\n\n');
    
    let contextPrompt = '';
    if (context && context.length > 0) {
      contextPrompt = '\n\nPrevious conversation for context:\n';
      context.forEach(c => {
        contextPrompt += `User: ${c.query}\nAssistant: ${c.response.substring(0, 300)}...\n\n`;
      });
    }
    
    const messages = [
      new SystemMessage(`${this.getCurrentDateContext()}

Answer the user's question based on the provided sources. Provide a clear, comprehensive answer with citations [1], [2], etc. Use markdown formatting for better readability. If this question relates to previous topics discussed, make connections where relevant.`),
      new HumanMessage(`Question: "${query}"${contextPrompt}\n\nBased on these sources:\n${sourcesText}`)
    ];
    
    let fullText = '';
    
    try {
      const stream = await this.streamingLlm.stream(messages);
      
      for await (const chunk of stream) {
        const content = chunk.content;
        if (typeof content === 'string') {
          fullText += content;
          onChunk(content);
        }
      }
    } catch (error) {
      // Fallback to non-streaming if streaming fails
      console.warn('Streaming failed, falling back to regular generation:', error);
      const response = await this.llm.invoke(messages);
      fullText = response.content.toString();
      onChunk(fullText);
    }
    
    return fullText;
  }

  private async generateFollowUpQuestions(
    originalQuery: string,
    answer: string,
    sources: Source[],
    context?: { query: string; response: string }[]
  ): Promise<string[]> {
    try {
      let contextPrompt = '';
      if (context && context.length > 0) {
        contextPrompt = '\n\nPrevious conversation topics:\n';
        context.forEach(c => {
          contextPrompt += `- ${c.query}\n`;
        });
        contextPrompt += '\nConsider the full conversation flow when generating follow-ups.\n';
      }
      
      const messages = [
        new SystemMessage(`${this.getCurrentDateContext()}

Based on this search query and answer, generate 3 relevant follow-up questions that the user might want to explore next.

Instructions:
- Generate exactly 3 follow-up questions
- Each question should explore a different aspect or dig deeper into the topic
- Questions should be natural and conversational
- They should build upon the information provided in the answer
- Make them specific and actionable
- Keep each question under 80 characters
- Return only the questions, one per line, no numbering or bullets
- Consider the entire conversation context when generating questions
- Only include time-relevant questions if the original query was about current events or trends

Examples of good follow-up questions:
- "How does this compare to [alternative]?"
- "Can you explain [technical term] in more detail?"
- "What are the practical applications of this?"
- "What are the main benefits and drawbacks?"
- "How is this typically implemented?"`),
        new HumanMessage(`Original query: "${originalQuery}"\n\nAnswer summary: ${answer.length > 1000 ? answer.slice(0, 1000) + '...' : answer}${contextPrompt}`)
      ];
      
      const response = await this.llm.invoke(messages);
      const questions = response.content.toString()
        .split('\n')
        .map(q => q.trim())
        .filter(q => q.length > 0 && q.length < 80)
        .slice(0, 3);
      
      return questions.length > 0 ? questions : [];
    } catch (error) {
      console.warn('Failed to generate follow-up questions:', error);
      return [];
    }
  }
}

================
File: lib/rate-limit.ts
================
import { Ratelimit } from "@upstash/ratelimit";
import { Redis } from "@upstash/redis";
import { NextRequest } from "next/server";

// Create a new ratelimiter that allows 50 requests per day per IP per endpoint
export const getRateLimiter = (endpoint: string) => {
  // Check if we're in a production environment to apply rate limiting
  // In development, we don't want to be rate limited for testing
  if (process.env.NODE_ENV !== "production" && !process.env.UPSTASH_REDIS_REST_URL) {
    return null;
  }

  // Requires the following environment variables:
  // UPSTASH_REDIS_REST_URL
  // UPSTASH_REDIS_REST_TOKEN
  const redis = Redis.fromEnv();

  return new Ratelimit({
    redis,
    limiter: Ratelimit.fixedWindow(50, "1 d"),
    analytics: true,
    prefix: `ratelimit:${endpoint}`,
  });
};

// Helper function to get the IP from a NextRequest or default to a placeholder
export const getIP = (request: NextRequest): string => {
  const forwarded = request.headers.get("x-forwarded-for");
  const realIp = request.headers.get("x-real-ip");
  
  if (forwarded) {
    return forwarded.split(/, /)[0];
  }
  
  if (realIp) {
    return realIp;
  }
  
  // Default to placeholder IP if none found
  return "127.0.0.1";
};

// Helper function to check if a request is rate limited
export const isRateLimited = async (request: NextRequest, endpoint: string) => {
  const limiter = getRateLimiter(endpoint);
  
  // If no limiter is available (e.g., in development), allow the request
  if (!limiter) {
    return { success: true, limit: 50, remaining: 50 };
  }
  
  // Get the IP from the request
  const ip = getIP(request);
  
  // Check if the IP has exceeded the rate limit
  const result = await limiter.limit(ip);
  
  return {
    success: result.success,
    limit: result.limit,
    remaining: result.remaining,
  };
};

================
File: lib/search-engine.ts
================
/* eslint-disable @typescript-eslint/no-explicit-any */
import { FirecrawlClient } from './firecrawl';
import { generateText, streamText } from 'ai';
import { openai } from '@ai-sdk/openai';
import { ContextProcessor } from './context-processor';

export type SearchPhase = 
  | 'understanding'
  | 'planning' 
  | 'searching'
  | 'analyzing'
  | 'synthesizing'
  | 'complete';

export type SearchEvent = 
  | { type: 'phase-update'; phase: SearchPhase; message: string }
  | { type: 'thinking'; message: string }
  | { type: 'searching'; query: string; index: number; total: number }
  | { type: 'found'; sources: Source[]; query: string }
  | { type: 'scraping'; url: string; index: number; total: number; query: string }
  | { type: 'content-chunk'; chunk: string }
  | { type: 'final-result'; content: string; sources: Source[]; followUpQuestions?: string[] }
  | { type: 'error'; error: string };

export interface Source {
  url: string;
  title: string;
  content?: string;
  quality?: number;
}

export interface SearchStep {
  id: SearchPhase | string;
  label: string;
  status: 'pending' | 'active' | 'completed';
  startTime?: number;
}

export class SearchEngine {
  private contextProcessor: ContextProcessor;
  
  constructor(private firecrawl: FirecrawlClient) {
    this.contextProcessor = new ContextProcessor();
  }

  getInitialSteps(): SearchStep[] {
    return [
      { id: 'understanding', label: 'Understanding request', status: 'pending' },
      { id: 'planning', label: 'Planning search', status: 'pending' },
      { id: 'searching', label: 'Searching sources', status: 'pending' },
      { id: 'analyzing', label: 'Analyzing content', status: 'pending' },
      { id: 'synthesizing', label: 'Synthesizing answer', status: 'pending' },
      { id: 'complete', label: 'Complete', status: 'pending' }
    ];
  }

  async search(
    query: string, 
    onEvent: (event: SearchEvent) => void,
    context?: { query: string; response: string }[]
  ): Promise<void> {
    try {
      // Phase 1: Understanding
      onEvent({ 
        type: 'phase-update', 
        phase: 'understanding',
        message: 'Analyzing your request...'
      });
      
      // Generate understanding of the query with context
      let understanding: string;
      try {
        understanding = await this.analyzeQuery(query, context);
      } catch (error) {
        onEvent({ 
          type: 'error', 
          error: error instanceof Error ? error.message : 'Failed to analyze query'
        });
        throw error;
      }
      
      onEvent({ 
        type: 'thinking', 
        message: understanding
      });

      // Phase 2: Planning
      onEvent({ 
        type: 'phase-update', 
        phase: 'planning',
        message: 'Planning search strategy...'
      });
      
      const searchQueries = await this.generateSearchQueries(query, context);
      
      onEvent({ 
        type: 'thinking', 
        message: searchQueries.length > 3 
          ? `I detected ${searchQueries.length} different questions/topics. I'll search for each one separately.`
          : `I'll search for ${searchQueries.length} different aspects of your question`
      });

      // Phase 3: Searching
      onEvent({ 
        type: 'phase-update', 
        phase: 'searching',
        message: 'Searching the web...'
      });
      
      const allSources: Source[] = [];
      
      for (let i = 0; i < searchQueries.length; i++) {
        const searchQuery = searchQueries[i];
        
        onEvent({ 
          type: 'searching', 
          query: searchQuery,
          index: i + 1,
          total: searchQueries.length
        });
        
        const results = await this.firecrawl.search(searchQuery, {
          limit: 5,
          scrapeOptions: {
            formats: ['markdown']
          }
        });
        
        const sources = results.data.map((r: any) => ({
          url: r.url,
          title: r.title,
          content: r.markdown || r.content || '',
          quality: 0
        }));
        
        onEvent({ 
          type: 'found', 
          sources,
          query: searchQuery
        });
        
        // Process sources - check if content already exists from search
        const topSources = sources.slice(0, 3);
        
        for (let j = 0; j < topSources.length; j++) {
          const source = topSources[j];
          
          // If we already have content from search, use it
          if (source.content && source.content.length > 100) {
            source.quality = this.scoreContent(source.content, query);
            allSources.push(source);
            onEvent({ 
              type: 'scraping', 
              url: source.url,
              index: j + 1,
              total: topSources.length,
              query: searchQuery
            });
            
            // Generate a brief summary of what was found
            const summary = await this.summarizeContent(source.content, searchQuery);
            if (summary) {
              onEvent({ 
                type: 'thinking', 
                message: summary
              });
            }
          } else {
            // Otherwise try to scrape
            onEvent({ 
              type: 'scraping', 
              url: source.url,
              index: j + 1,
              total: topSources.length,
              query: searchQuery
            });
            
            try {
              const scraped = await this.firecrawl.scrapeUrl(source.url, 15000);
              if (scraped.success && scraped.markdown) {
                source.content = scraped.markdown;
                source.quality = this.scoreContent(scraped.markdown, query);
                allSources.push(source);
                
                // Generate a brief summary of what was found
                const summary = await this.summarizeContent(scraped.markdown, searchQuery);
                if (summary) {
                  onEvent({ 
                    type: 'thinking', 
                    message: summary
                  });
                }
              } else if (scraped.error === 'timeout') {
                // Handle timeout specifically
                console.warn(`Scraping ${source.url} timed out after 15 seconds`);
                onEvent({ 
                  type: 'thinking', 
                  message: `${new URL(source.url).hostname} is taking too long to respond, moving on...`
                });
              }
            } catch (error) {
              // Log error but continue with other sources
              console.warn(`Failed to scrape ${source.url}:`, error);
              onEvent({ 
                type: 'thinking', 
                message: `Couldn't access ${new URL(source.url).hostname}, trying other sources...`
              });
            }
          }
          
          await this.simulateWork(300);
        }
      }

      // Phase 4: Analyzing
      onEvent({ 
        type: 'phase-update', 
        phase: 'analyzing',
        message: 'Analyzing gathered information...'
      });
      
      await this.simulateWork(1500);
      
      onEvent({ 
        type: 'thinking', 
        message: `Found ${allSources.length} relevant sources with quality information`
      });

      // Phase 5: Synthesizing
      onEvent({ 
        type: 'phase-update', 
        phase: 'synthesizing',
        message: 'Creating comprehensive answer...'
      });
      
      // Process sources with context processor
      onEvent({ 
        type: 'thinking', 
        message: `Processing ${allSources.length} sources with AI summarization for optimal relevance...`
      });
      
      const processedSources = await this.contextProcessor.processSources(
        query,
        allSources,
        searchQueries
      );
      
      // Stream the answer
      const answer = await this.generateStreamingAnswer(
        query, 
        processedSources,
        (chunk) => onEvent({ type: 'content-chunk', chunk }),
        context
      );

      // Generate follow-up questions
      const followUpQuestions = await this.generateFollowUpQuestions(query, answer, processedSources, context);

      // Phase 6: Complete
      onEvent({ 
        type: 'phase-update', 
        phase: 'complete',
        message: 'Search complete!'
      });
      
      onEvent({ 
        type: 'final-result', 
        content: answer,
        sources: allSources.filter(s => s.content),
        followUpQuestions
      });
      
    } catch (error) {
      onEvent({ 
        type: 'error', 
        error: error instanceof Error ? error.message : 'Search failed' 
      });
    }
  }

  private async simulateWork(ms: number): Promise<void> {
    await new Promise(resolve => setTimeout(resolve, ms));
  }

  private async analyzeQuery(query: string, context?: { query: string; response: string }[]): Promise<string> {
    try {
      let contextPrompt = '';
      if (context && context.length > 0) {
        contextPrompt = '\n\nPrevious conversation:\n';
        context.forEach(c => {
          // Limit context response to avoid token issues
          const limitedResponse = c.response.length > 1000 
            ? c.response.slice(0, 1000) + '...' 
            : c.response;
          contextPrompt += `User: ${c.query}\nAssistant: ${limitedResponse}\n\n`;
        });
      }
      
      const result = await generateText({
        model: openai('gpt-4o'),
        prompt: `Analyze this search query and explain what you understand the user is looking for: "${query}"
${contextPrompt}
Instructions:
- Start with a clear, concise title in quotes (e.g., "Researching egg shortage" or "Understanding climate change impacts")
- Then explain in 1-2 sentences what aspects of the topic the user wants to know about
- If this relates to previous questions, acknowledge that connection
- Finally, mention that you'll search for the latest information to help answer their question
- DO NOT use any markdown formatting, code blocks, or special characters

Keep it natural and conversational, showing you truly understand their request.`,
      });
      
      return result.text.trim();
    } catch (error) {
      console.error('Error analyzing query:', error);
      // Check if it's an API key error
      if (error instanceof Error && error.message.includes('API key')) {
        throw new Error('OpenAI API key is required. Please set OPENAI_API_KEY in your environment variables.');
      }
      throw error;
    }
  }

  private async generateSearchQueries(query: string, context?: { query: string; response: string }[]): Promise<string[]> {
    let contextPrompt = '';
    if (context && context.length > 0) {
      contextPrompt = '\n\nPrevious conversation context:\n';
      context.forEach(c => {
        // Limit context response to avoid token issues
        const limitedResponse = c.response.length > 500 
          ? c.response.slice(0, 500) + '...' 
          : c.response;
        contextPrompt += `User: ${c.query}\nAssistant discussed: ${limitedResponse}\n\n`;
      });
      contextPrompt += '\nIf the current query refers to items from the previous conversation (like "Which phone" when phones were discussed), make sure to include those specific items in your search queries.\n';
    }
    
    const result = await generateText({
      model: openai('gpt-4o'),
      prompt: `Analyze this query and generate appropriate search queries: "${query}"
${contextPrompt}
Instructions:
- For simple queries (e.g., "What is X?")  use just 1 search
- For queries with multiple distinct questions  create a separate search for EACH question
- For lists or multiple items  create individual searches for each item
- Don't artificially group unrelated topics together
- Each search should be focused and specific
- If the query refers to previous context (like "which one" or "the best of those"), include the specific items from context

Examples:
- "What is firecrawl?"  1 search: "firecrawl overview features documentation"
- "What is X? How does Y work? Where to buy Z?"  3 separate searches
- "Tell me about A, B, C, D, and E"  5 separate searches (one for each)
- "Compare React vs Vue vs Angular"  3 searches (one for each framework)
- "What are the top 10 programming languages?"  1 search (single topic)

Important: If the user asks about multiple distinct things, create separate searches. Don't force them into fewer searches.

Return ONLY the search queries, one per line. Do not include any markdown, code blocks, backticks, bullet points, or explanations - just the plain text search queries.`,
    });
    
    const queries = result.text
      .split('\n')
      .map(q => q.trim())
      .map(q => q.replace(/^["']|["']$/g, '')) // Remove surrounding quotes
      .filter(q => q.length > 0)
      .filter(q => !q.match(/^```/)) // Filter out markdown code blocks
      .filter(q => !q.match(/^[-*#]/)) // Filter out markdown lists/headers
      .filter(q => q.length > 3); // Filter out very short strings
    
    // Allow up to 12 searches for complex queries
    return queries.slice(0, 12);
  }

  private scoreContent(content: string, query: string): number {
    const queryWords = query.toLowerCase().split(' ');
    const contentLower = content.toLowerCase();
    
    let score = 0;
    for (const word of queryWords) {
      if (contentLower.includes(word)) score += 0.2;
    }
    
    return Math.min(score, 1);
  }

  private async summarizeContent(content: string, query: string): Promise<string> {
    try {
      // Limit content for summarization to avoid token limits
      const maxContentLength = 8000;
      const truncatedContent = content.length > maxContentLength 
        ? content.slice(0, maxContentLength) + '...' 
        : content;
      
      const result = await generateText({
        model: openai('gpt-4o'),
        prompt: `Extract one key finding from this content that's relevant to the search query: "${query}"

Content: ${truncatedContent}

Instructions:
- Return just ONE sentence summarizing the most important finding
- Make it specific and factual (include numbers, dates, or specific details if relevant)
- Keep it under 100 characters
- Don't include any prefixes like "The article states" or "According to"`,
      });
      
      return result.text.trim();
    } catch (error) {
      console.warn('Failed to summarize content:', error);
      return '';
    }
  }

  private async generateStreamingAnswer(
    query: string, 
    sources: Source[],
    onChunk: (chunk: string) => void,
    context?: { query: string; response: string }[]
  ): Promise<string> {
    // Sources are already processed by ContextProcessor
    const sourcesText = sources
      .map((s, i) => {
        if (!s.content) return `[${i + 1}] ${s.title}\n[No content available]`;
        return `[${i + 1}] ${s.title}\n${s.content}`;
      })
      .join('\n\n');
    
    let contextPrompt = '';
    if (context && context.length > 0) {
      contextPrompt = '\n\nPrevious conversation for context:\n';
      context.forEach(c => {
        // Limit context response to avoid token issues
        const limitedResponse = c.response.length > 1000 
          ? c.response.slice(0, 1000) + '...' 
          : c.response;
        contextPrompt += `User: ${c.query}\nAssistant: ${limitedResponse}\n\n`;
      });
    }
    
    try {
      const { textStream } = await streamText({
        model: openai('gpt-4o'),
        prompt: `Answer this question: "${query}"
${contextPrompt}
Based on these sources:
${sourcesText}

Provide a clear, comprehensive answer with citations [1], [2], etc. Use markdown formatting for better readability. If this question relates to previous topics discussed, make connections where relevant.`,
      });
    
      let fullText = '';
      
      for await (const chunk of textStream) {
        fullText += chunk;
        onChunk(chunk);
      }
      
      return fullText;
    } catch (error) {
      console.error('Error generating streaming answer:', error);
      
      // Provide a fallback response with the error
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      const fallbackResponse = `I encountered an error while processing your request. The sources were found successfully, but there was an issue generating the response.

Error: ${errorMessage}

Here are the sources that were found:
${sources.map((s, i) => `[${i + 1}] ${s.title} - ${s.url}`).join('\n')}`;
      
      // Stream the error message
      for (const char of fallbackResponse) {
        onChunk(char);
        await new Promise(resolve => setTimeout(resolve, 10));
      }
      
      return fallbackResponse;
    }
  }

  private async generateFollowUpQuestions(
    originalQuery: string,
    answer: string,
    sources: Source[],
    context?: { query: string; response: string }[]
  ): Promise<string[]> {
    try {
      let contextPrompt = '';
      if (context && context.length > 0) {
        contextPrompt = '\n\nPrevious conversation topics:\n';
        context.forEach(c => {
          contextPrompt += `- ${c.query}\n`;
        });
        contextPrompt += '\nConsider the full conversation flow when generating follow-ups.\n';
      }
      
      const result = await generateText({
        model: openai('gpt-4o'),
        prompt: `Based on this search query and answer, generate 3 relevant follow-up questions that the user might want to explore next.

Original query: "${originalQuery}"

Answer summary: ${answer.length > 1000 ? answer.slice(0, 1000) + '...' : answer}
${contextPrompt}
Instructions:
- Generate exactly 3 follow-up questions
- Each question should explore a different aspect or dig deeper into the topic
- Questions should be natural and conversational
- They should build upon the information provided in the answer
- Make them specific and actionable
- Keep each question under 80 characters
- Return only the questions, one per line, no numbering or bullets
- Consider the entire conversation context when generating questions

Examples of good follow-up questions:
- "How does this compare to [alternative]?"
- "What are the latest developments in [specific aspect]?"
- "Can you explain [technical term] in more detail?"
- "What are the practical applications of this?"
- "How has this changed over the past year?"`,
      });
      
      const questions = result.text
        .split('\n')
        .map(q => q.trim())
        .filter(q => q.length > 0 && q.length < 80)
        .slice(0, 3);
      
      return questions.length > 0 ? questions : [];
    } catch (error) {
      console.warn('Failed to generate follow-up questions:', error);
      return [];
    }
  }
}

================
File: lib/storage.ts
================
import { Redis } from '@upstash/redis'

export interface IndexMetadata {
  url: string
  namespace: string
  pagesCrawled: number
  createdAt: string
  metadata?: {
    title?: string
    description?: string
    favicon?: string
    ogImage?: string
  }
}

interface StorageAdapter {
  getIndexes(): Promise<IndexMetadata[]>
  getIndex(namespace: string): Promise<IndexMetadata | null>
  saveIndex(index: IndexMetadata): Promise<void>
  deleteIndex(namespace: string): Promise<void>
}

class LocalStorageAdapter implements StorageAdapter {
  private readonly STORAGE_KEY = 'firestarter_indexes'

  async getIndexes(): Promise<IndexMetadata[]> {
    if (typeof window === 'undefined') return []
    
    try {
      const stored = localStorage.getItem(this.STORAGE_KEY)
      return stored ? JSON.parse(stored) : []
    } catch (error) {
      console.error('Error reading from localStorage:', error)
      return []
    }
  }

  async getIndex(namespace: string): Promise<IndexMetadata | null> {
    const indexes = await this.getIndexes()
    return indexes.find(i => i.namespace === namespace) || null
  }

  async saveIndex(index: IndexMetadata): Promise<void> {
    if (typeof window === 'undefined') {
      throw new Error('localStorage is not available on the server')
    }
    
    const indexes = await this.getIndexes()
    const existingIndex = indexes.findIndex(i => i.namespace === index.namespace)
    
    if (existingIndex !== -1) {
      indexes[existingIndex] = index
    } else {
      indexes.unshift(index)
    }
    
    // Keep only the last 50 indexes
    const limitedIndexes = indexes.slice(0, 50)
    
    try {
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(limitedIndexes))
    } catch (error) {
      console.error('Error saving to localStorage:', error)
      throw error
    }
  }

  async deleteIndex(namespace: string): Promise<void> {
    if (typeof window === 'undefined') {
      throw new Error('localStorage is not available on the server')
    }
    
    const indexes = await this.getIndexes()
    const filteredIndexes = indexes.filter(i => i.namespace !== namespace)
    
    try {
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(filteredIndexes))
    } catch (error) {
      console.error('Error deleting from localStorage:', error)
      throw error
    }
  }
}

class RedisStorageAdapter implements StorageAdapter {
  private redis: Redis
  private readonly INDEXES_KEY = 'firestarter:indexes'
  private readonly INDEX_KEY_PREFIX = 'firestarter:index:'

  constructor() {
    if (!process.env.UPSTASH_REDIS_REST_URL || !process.env.UPSTASH_REDIS_REST_TOKEN) {
      throw new Error('Redis configuration missing')
    }
    
    this.redis = new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN,
    })
  }

  async getIndexes(): Promise<IndexMetadata[]> {
    try {
      const indexes = await this.redis.get<IndexMetadata[]>(this.INDEXES_KEY)
      return indexes || []
    } catch (error) {
      console.error('Error fetching indexes from Redis:', error)
      return []
    }
  }

  async getIndex(namespace: string): Promise<IndexMetadata | null> {
    try {
      const index = await this.redis.get<IndexMetadata>(`${this.INDEX_KEY_PREFIX}${namespace}`)
      return index
    } catch (error) {
      console.error('Error fetching index from Redis:', error)
      return null
    }
  }

  async saveIndex(index: IndexMetadata): Promise<void> {
    try {
      // Save individual index
      await this.redis.set(`${this.INDEX_KEY_PREFIX}${index.namespace}`, index)
      
      // Update indexes list
      const indexes = await this.getIndexes()
      const existingIndex = indexes.findIndex(i => i.namespace === index.namespace)
      
      if (existingIndex !== -1) {
        indexes[existingIndex] = index
      } else {
        indexes.unshift(index)
      }
      
      // Keep only the last 50 indexes
      const limitedIndexes = indexes.slice(0, 50)
      await this.redis.set(this.INDEXES_KEY, limitedIndexes)
    } catch (error) {
      console.error('Error saving index to Redis:', error)
      throw error
    }
  }

  async deleteIndex(namespace: string): Promise<void> {
    try {
      // Delete individual index
      await this.redis.del(`${this.INDEX_KEY_PREFIX}${namespace}`)
      
      // Update indexes list
      const indexes = await this.getIndexes()
      const filteredIndexes = indexes.filter(i => i.namespace !== namespace)
      await this.redis.set(this.INDEXES_KEY, filteredIndexes)
    } catch (error) {
      console.error('Error deleting index from Redis:', error)
      throw error
    }
  }
}

// Factory function to get the appropriate storage adapter
function getStorageAdapter(): StorageAdapter {
  // Use Redis if both environment variables are set
  if (process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN) {
    return new RedisStorageAdapter()
  }
  
  // Check if we're on the server
  if (typeof window === 'undefined') {
    throw new Error('No storage adapter available on the server. Please configure Redis by setting UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN environment variables.')
  }
  
  // Otherwise, use localStorage (only on client)
  return new LocalStorageAdapter()
}

// Lazy initialization to avoid errors at module load time
let storage: StorageAdapter | null = null

function getStorage(): StorageAdapter {
  if (!storage) {
    storage = getStorageAdapter()
  }
  return storage
}

export const getIndexes = () => {
  try {
    return getStorage().getIndexes()
  } catch (error) {
    console.error('Storage adapter error:', error)
    return Promise.resolve([])
  }
}

export const getIndex = (namespace: string) => {
  try {
    return getStorage().getIndex(namespace)
  } catch (error) {
    console.error('Storage adapter error:', error)
    return Promise.resolve(null)
  }
}

export const saveIndex = (index: IndexMetadata) => {
  try {
    return getStorage().saveIndex(index)
  } catch (error) {
    console.error('Storage adapter error:', error)
    return Promise.reject(error)
  }
}

export const deleteIndex = (namespace: string) => {
  try {
    return getStorage().deleteIndex(namespace)
  } catch (error) {
    console.error('Storage adapter error:', error)
    return Promise.reject(error)
  }
}

================
File: lib/upstash-search.ts
================
import { Search } from '@upstash/search'

// Initialize Upstash Search client
const searchClient = new Search({
  url: process.env.UPSTASH_SEARCH_REST_URL!,
  token: process.env.UPSTASH_SEARCH_REST_TOKEN!,
})

// Create a search index for firestarter documents
export const searchIndex = searchClient.index<FirestarterContent>('firestarter')

export interface FirestarterContent {
  text: string
  url: string
  title: string
  [key: string]: unknown // Add index signature for Upstash type compatibility
}

export interface FirestarterIndex {
  namespace: string
  url: string
  pagesCrawled: number
  crawlDate: string
  metadata: {
    title: string
    description?: string
    favicon?: string
    ogImage?: string
  }
}

================
File: lib/utils.ts
================
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: public/assets/twemoji-fire.svg
================
<svg width="800px" height="800px" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--twemoji" preserveAspectRatio="xMidYMid meet"><path fill="#F4900C" d="M35 19a16.96 16.96 0 0 0-1.04-5.868c-.46 5.389-3.333 8.157-6.335 6.868c-2.812-1.208-.917-5.917-.777-8.164c.236-3.809-.012-8.169-6.931-11.794c2.875 5.5.333 8.917-2.333 9.125c-2.958.231-5.667-2.542-4.667-7.042c-3.238 2.386-3.332 6.402-2.333 9c1.042 2.708-.042 4.958-2.583 5.208c-2.84.28-4.418-3.041-2.963-8.333A16.936 16.936 0 0 0 1 19c0 9.389 7.611 17 17 17s17-7.611 17-17z"></path><path fill="#FFCC4D" d="M28.394 23.999c.148 3.084-2.561 4.293-4.019 3.709c-2.106-.843-1.541-2.291-2.083-5.291s-2.625-5.083-5.708-6c2.25 6.333-1.247 8.667-3.08 9.084c-1.872.426-3.753-.001-3.968-4.007A11.964 11.964 0 0 0 6 30c0 .368.023.73.055 1.09C9.125 34.124 13.342 36 18 36s8.875-1.876 11.945-4.91c.032-.36.055-.722.055-1.09c0-2.187-.584-4.236-1.606-6.001z"></path></svg>

================
File: public/file.svg
================
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

================
File: public/firecrawl-logo.svg
================
<svg width="2907" height="600" viewBox="0 0 2907 600" fill="none" xmlns="http://www.w3.org/2000/svg">
<text x="0" y="599.93" fontSize="600" dominant-baseline="text-after-edge"></text>
<path d="M768.456 483V119.364H993.953V166.594H823.321V277.389H977.796V324.442H823.321V483H768.456ZM1052.16 483V210.273H1105.25V483H1052.16ZM1078.97 168.192C1069.74 168.192 1061.81 165.114 1055.18 158.959C1048.67 152.685 1045.42 145.228 1045.42 136.587C1045.42 127.827 1048.67 120.37 1055.18 114.214C1061.81 107.941 1069.74 104.804 1078.97 104.804C1088.21 104.804 1096.08 107.941 1102.59 114.214C1109.22 120.37 1112.53 127.827 1112.53 136.587C1112.53 145.228 1109.22 152.685 1102.59 158.959C1096.08 165.114 1088.21 168.192 1078.97 168.192ZM1171.68 483V210.273H1222.99V253.597H1225.83C1230.8 238.919 1239.56 227.377 1252.11 218.973C1264.77 210.45 1279.1 206.189 1295.08 206.189C1298.39 206.189 1302.3 206.307 1306.8 206.544C1311.41 206.781 1315.02 207.077 1317.63 207.432V258.213C1315.5 257.621 1311.71 256.97 1306.26 256.26C1300.82 255.431 1295.37 255.017 1289.93 255.017C1277.38 255.017 1266.19 257.68 1256.37 263.007C1246.66 268.215 1238.97 275.495 1233.29 284.847C1227.61 294.08 1224.76 304.615 1224.76 316.452V483H1171.68ZM1466.35 488.504C1439.48 488.504 1416.33 482.763 1396.92 471.281C1377.63 459.681 1362.71 443.405 1352.18 422.453C1341.76 401.383 1336.55 376.703 1336.55 348.412C1336.55 320.476 1341.76 295.855 1352.18 274.548C1362.71 253.241 1377.39 236.61 1396.21 224.655C1415.15 212.699 1437.29 206.722 1462.62 206.722C1478.01 206.722 1492.92 209.267 1507.36 214.357C1521.8 219.446 1534.77 227.437 1546.25 238.327C1557.73 249.217 1566.78 263.362 1573.41 280.763C1580.04 298.045 1583.36 319.056 1583.36 343.795V362.616H1366.56V322.844H1531.33C1531.33 308.876 1528.49 296.506 1522.81 285.734C1517.13 274.844 1509.14 266.262 1498.84 259.989C1488.66 253.715 1476.7 250.578 1462.97 250.578C1448.06 250.578 1435.04 254.248 1423.91 261.587C1412.9 268.807 1404.38 278.277 1398.34 289.996C1392.42 301.596 1389.46 314.203 1389.46 327.815V358.888C1389.46 377.117 1392.66 392.624 1399.05 405.408C1405.56 418.192 1414.62 427.957 1426.22 434.705C1437.82 441.333 1451.37 444.648 1466.88 444.648C1476.94 444.648 1486.11 443.227 1494.4 440.386C1502.69 437.427 1509.85 433.047 1515.89 427.247C1521.92 421.447 1526.54 414.286 1529.73 405.763L1579.98 414.818C1575.96 429.615 1568.74 442.576 1558.32 453.703C1548.02 464.712 1535.06 473.294 1519.44 479.449C1503.93 485.486 1486.23 488.504 1466.35 488.504ZM1752.14 488.504C1725.74 488.504 1703.02 482.527 1683.96 470.571C1665.02 458.497 1650.46 441.866 1640.28 420.678C1630.1 399.489 1625.01 375.223 1625.01 347.879C1625.01 320.18 1630.22 295.737 1640.63 274.548C1651.05 253.241 1665.73 236.61 1684.67 224.655C1703.61 212.699 1725.92 206.722 1751.61 206.722C1772.32 206.722 1790.79 210.569 1807.01 218.263C1823.22 225.839 1836.3 236.492 1846.25 250.223C1856.31 263.954 1862.28 279.993 1864.18 298.341H1812.51C1809.67 285.557 1803.16 274.548 1792.98 265.315C1782.92 256.082 1769.42 251.466 1752.5 251.466C1737.7 251.466 1724.74 255.372 1713.61 263.185C1702.6 270.879 1694.02 281.887 1687.86 296.21C1681.71 310.415 1678.63 327.223 1678.63 346.636C1678.63 366.523 1681.65 383.687 1687.69 398.128C1693.72 412.569 1702.25 423.755 1713.26 431.686C1724.38 439.617 1737.46 443.582 1752.5 443.582C1762.56 443.582 1771.67 441.748 1779.84 438.078C1788.13 434.29 1795.05 428.904 1800.61 421.92C1806.3 414.937 1810.26 406.532 1812.51 396.707H1864.18C1862.28 414.345 1856.54 430.088 1846.96 443.938C1837.37 457.787 1824.52 468.677 1808.43 476.608C1792.45 484.539 1773.68 488.504 1752.14 488.504ZM1915.95 483V210.273H1967.27V253.597H1970.11C1975.08 238.919 1983.84 227.377 1996.39 218.973C2009.05 210.45 2023.37 206.189 2039.35 206.189C2042.67 206.189 2046.58 206.307 2051.07 206.544C2055.69 206.781 2059.3 207.077 2061.9 207.432V258.213C2059.77 257.621 2055.99 256.97 2050.54 256.26C2045.1 255.431 2039.65 255.017 2034.21 255.017C2021.66 255.017 2010.47 257.68 2000.65 263.007C1990.94 268.215 1983.25 275.495 1977.56 284.847C1971.88 294.08 1969.04 304.615 1969.04 316.452V483H1915.95ZM2179.77 489.037C2162.49 489.037 2146.87 485.841 2132.9 479.449C2118.93 472.938 2107.86 463.528 2099.7 451.217C2091.65 438.907 2087.62 423.814 2087.62 405.94C2087.62 390.552 2090.58 377.886 2096.5 367.943C2102.42 358 2110.41 350.128 2120.47 344.328C2130.53 338.528 2141.78 334.148 2154.21 331.189C2166.63 328.23 2179.3 325.981 2192.2 324.442C2208.54 322.548 2221.8 321.009 2231.98 319.825C2242.16 318.523 2249.55 316.452 2254.17 313.611C2258.79 310.77 2261.09 306.153 2261.09 299.761V298.518C2261.09 283.012 2256.71 270.997 2247.96 262.474C2239.31 253.952 2226.41 249.69 2209.25 249.69C2191.37 249.69 2177.29 253.656 2166.99 261.587C2156.81 269.399 2149.77 278.099 2145.86 287.688L2095.97 276.324C2101.89 259.752 2110.53 246.376 2121.89 236.196C2133.37 225.898 2146.57 218.44 2161.49 213.824C2176.4 209.089 2192.08 206.722 2208.54 206.722C2219.43 206.722 2230.97 208.024 2243.16 210.628C2255.47 213.114 2266.95 217.73 2277.61 224.477C2288.38 231.224 2297.2 240.872 2304.06 253.419C2310.93 265.848 2314.36 282.006 2314.36 301.892V483H2262.52V445.713H2260.38C2256.95 452.579 2251.8 459.326 2244.94 465.955C2238.07 472.583 2229.25 478.088 2218.48 482.467C2207.71 486.847 2194.81 489.037 2179.77 489.037ZM2191.31 446.423C2205.99 446.423 2218.54 443.523 2228.96 437.723C2239.49 431.923 2247.48 424.347 2252.93 414.996C2258.49 405.526 2261.27 395.405 2261.27 384.634V349.477C2259.38 351.371 2255.71 353.147 2250.26 354.804C2244.94 356.343 2238.84 357.704 2231.98 358.888C2225.11 359.953 2218.42 360.959 2211.91 361.906C2205.4 362.735 2199.96 363.445 2195.58 364.037C2185.28 365.339 2175.87 367.529 2167.34 370.607C2158.94 373.684 2152.19 378.123 2147.1 383.923C2142.13 389.605 2139.65 397.181 2139.65 406.651C2139.65 419.79 2144.5 429.733 2154.21 436.48C2163.91 443.109 2176.28 446.423 2191.31 446.423ZM2439.2 483L2358.94 210.273H2413.81L2467.25 410.557H2469.92L2523.54 210.273H2578.4L2631.67 409.669H2634.34L2687.42 210.273H2742.29L2662.21 483H2608.06L2552.66 286.089H2548.58L2493.18 483H2439.2ZM2840.76 119.364V483H2787.67V119.364H2840.76Z" fill="#36322F"/>
</svg>

================
File: public/globe.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

================
File: public/window.svg
================
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: eslint.config.mjs
================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;

================
File: layout.tsx
================
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Firestarter by Firecrawl - Instant AI Chatbots from Any Website",
  description: "Drop a URL and instantly create a custom AI chatbot with API access. Build knowledge bases from any website in seconds with Firecrawl's advanced web scraping.",
  openGraph: {
    title: "Firestarter - Instant AI Chatbots from Any Website",
    description: "Drop a URL and instantly create a custom AI chatbot with API access. Powered by Firecrawl.",
    url: "/firestarter",
    siteName: "Firecrawl Tools",
    images: [
      {
        url: "/firecrawl-logo-with-fire.png",
        width: 1200,
        height: 630,
        alt: "Firestarter by Firecrawl - Instant Website Chatbots",
      },
    ],
    locale: "en_US",
    type: "website",
  },
  twitter: {
    card: "summary_large_image",
    title: "Firestarter - Instant AI Chatbots from URLs",
    description: "Create custom AI chatbots from any website in seconds",
    images: ["/firecrawl-logo-with-fire.png"],
    creator: "@firecrawl_dev",
  },
  keywords: ["chatbot", "ai", "web scraping", "firecrawl", "knowledge base", "url to chatbot", "website chatbot"],
};

export default function FirestarterLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return children;
}

================
File: next.config.ts
================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  assetPrefix: process.env.NEXT_PUBLIC_ASSET_PREFIX || './',
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'www.google.com',
        pathname: '/s2/favicons**',
      },
      {
        protocol: 'https',
        hostname: '**',
      },
      {
        protocol: 'http',
        hostname: '**',
      },
    ],
  },
};

export default nextConfig;

================
File: package.json
================
{
  "name": "firecrawl-template",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^1.2.12",
    "@ai-sdk/google": "^1.2.18",
    "@ai-sdk/groq": "^1.2.9",
    "@ai-sdk/openai": "^1.3.22",
    "@ai-sdk/openai-compatible": "^0.2.14",
    "@fal-ai/client": "^1.4.0",
    "@hookform/resolvers": "^5.0.1",
    "@langchain/core": "^0.3.57",
    "@langchain/langgraph": "^0.2.74",
    "@langchain/openai": "^0.5.11",
    "@mendable/firecrawl-js": "^1.25.1",
    "@openai/agents": "^0.0.1",
    "@radix-ui/react-accordion": "^1.2.10",
    "@radix-ui/react-alert-dialog": "^1.1.13",
    "@radix-ui/react-aspect-ratio": "^1.1.6",
    "@radix-ui/react-avatar": "^1.1.9",
    "@radix-ui/react-checkbox": "^1.3.1",
    "@radix-ui/react-collapsible": "^1.1.10",
    "@radix-ui/react-context-menu": "^2.2.14",
    "@radix-ui/react-dialog": "^1.1.13",
    "@radix-ui/react-dropdown-menu": "^2.1.14",
    "@radix-ui/react-hover-card": "^1.1.13",
    "@radix-ui/react-label": "^2.1.6",
    "@radix-ui/react-menubar": "^1.1.14",
    "@radix-ui/react-navigation-menu": "^1.2.12",
    "@radix-ui/react-popover": "^1.1.13",
    "@radix-ui/react-progress": "^1.1.6",
    "@radix-ui/react-radio-group": "^1.3.6",
    "@radix-ui/react-scroll-area": "^1.2.8",
    "@radix-ui/react-select": "^2.2.4",
    "@radix-ui/react-separator": "^1.1.6",
    "@radix-ui/react-slider": "^1.3.4",
    "@radix-ui/react-slot": "^1.2.2",
    "@radix-ui/react-switch": "^1.2.4",
    "@radix-ui/react-tabs": "^1.1.11",
    "@radix-ui/react-toggle": "^1.1.8",
    "@radix-ui/react-toggle-group": "^1.1.9",
    "@radix-ui/react-tooltip": "^1.2.6",
    "@types/uuid": "^10.0.0",
    "@upstash/ratelimit": "^2.0.5",
    "@upstash/redis": "^1.34.9",
    "@upstash/search": "^0.1.0",
    "@vercel/analytics": "^1.5.0",
    "ai": "^4.3.16",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "date-fns": "^4.1.0",
    "embla-carousel-react": "^8.6.0",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.511.0",
    "next": "15.3.2",
    "next-themes": "^0.4.6",
    "openai": "^4.73.0",
    "papaparse": "^5.4.1",
    "react": "^19.0.0",
    "react-day-picker": "8.10.1",
    "react-dom": "^19.0.0",
    "react-dropzone": "^14.3.5",
    "react-hook-form": "^7.56.4",
    "react-markdown": "^10.1.0",
    "react-resizable-panels": "^3.0.2",
    "recharts": "^2.15.3",
    "remark-gfm": "^4.0.1",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.3.0",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^11.1.0",
    "vaul": "^1.1.2",
    "zod": "^3.25.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@shadcn/ui": "^0.0.4",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/papaparse": "^5.3.14",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.2",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.0",
    "typescript": "^5"
  }
}

================
File: postcss.config.mjs
================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";
import defaultTheme from "tailwindcss/defaultTheme";

export default {
  content: [
    "./app/**/*.{js,ts,jsx,tsx}",
    "./pages/**/*.{js,ts,jsx,tsx}",
    "./components/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      fontFamily: {
        sans: ["var(--font-inter)", ...defaultTheme.fontFamily.sans],
        mono: defaultTheme.fontFamily.mono,
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

================
File: vercel.json
================
{
  "functions": {
    "app/api/*/route.ts": {
      "maxDuration": 300
    },
    "app/api/enrich/route.ts": {
      "maxDuration": 300
    },
    "app/firesearch/search.tsx": {
      "maxDuration": 300
    }
  }
}
